local ReplicatedStorage = game:GetService("ReplicatedStorage")

local BridgeNet2 = require(ReplicatedStorage.GunShared.Packages.BridgeNet2)

return {
	Fire = BridgeNet2.ReferenceBridge("GunFireBridge"),
	Reload = BridgeNet2.ReferenceBridge("GunReloadBridge"),
	Hit = BridgeNet2.ReferenceBridge("GunHitBridge"),
	CreateBullet = BridgeNet2.ReferenceBridge("GunCreateBulletBridge"),
}


--!native
--!strict

local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Parent.Packages.Signal)

local Connection = if RunService:IsClient() then RunService.RenderStepped else RunService.Heartbeat

local DEFAULT_RANGE = 3000
local DEFAULT_VELOCITY = 1500

local Caster = {}
Caster.__index = Caster

function Caster.new()
	local self = setmetatable({}, Caster)

	self.RayHit = Signal.new()
	self.PositionChanged = Signal.new()
	self.CastTerminating = Signal.new()

	return self
end

function Caster:_disconnectRunServiceConnection()
	if self._runServiceConnection then
		self._runServiceConnection:Disconnect()
	end
end

function Caster:_onUpdate(deltaTime: number)
	assert(typeof(self._direction) == "Vector3", "Bad direction")
	assert(typeof(self._origin) == "Vector3", "Bad origin")
	assert(typeof(self._position) == "Vector3", "Bad position")

	task.desynchronize()
	debug.profilebegin("Caster:_onUpdate")

	local direction: Vector3 = self._direction * self._velocity * deltaTime
	local distance: number = (self._origin - self._position).Magnitude
	local position: Vector3 = self._position + direction
	local raycastResult: RaycastResult? = workspace:Raycast(self._position, direction, self._raycastParams)

	debug.profileend()
	task.synchronize()

	self.PositionChanged:Fire(if raycastResult then raycastResult.Position else position, deltaTime)

	if distance >= self._range then
		self.CastTerminating:Fire()
		self:_disconnectRunServiceConnection()
		return
	end

	if raycastResult then
		self.RayHit:Fire(raycastResult)
		self:_disconnectRunServiceConnection()
		return
	end

	self._position = position
end

function Caster:Fire(origin: Vector3, direction: Vector3, velocity: number, raycastParams: RaycastParams?)
	self._startTick = tick()

	self._origin = origin
	self._direction = direction
	self._raycastParams = raycastParams
	self._position = self._origin

	self._velocity = velocity or DEFAULT_VELOCITY
	self._range = DEFAULT_RANGE

	self._runServiceConnection = Connection:ConnectParallel(function(deltaTime: number)
		self:_onUpdate(deltaTime)
	end)
end

function Caster:Destroy()
	self:_disconnectRunServiceConnection()
	table.clear(self)
	setmetatable(self, nil)
end

return Caster



local GunModules = game:GetService("ReplicatedStorage"):WaitForChild("GunShared"):WaitForChild("Modules")
local Camera = workspace.CurrentCamera

local Raycast = {}

function Raycast:GetParallel(origin: Vector3, direction: Vector3, raycastParams: RaycastParams?): RaycastResult?
	task.desynchronize()
	local raycastResult = Raycast:Get(origin, direction, raycastParams)
	task.synchronize()

	return raycastResult
end

function Raycast:Get(origin: Vector3, direction: Vector3, raycastParams: RaycastParams?): RaycastResult?
	return workspace:Raycast(origin, direction, raycastParams)
end

function Raycast.newParams(ignoreInstances: { Instance }?, filter: Enum.RaycastFilterType?): RaycastParams
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = ignoreInstances or {}
	raycastParams.FilterType = filter or Enum.RaycastFilterType.Exclude
	raycastParams.RespectCanCollide = true
	return raycastParams
end

function Raycast:GetWallHit(
	origin: Vector3,
	target: Vector3,
	root: Vector3,
	ignoreInstances: { Instance }?
): RaycastResult
	local raycastParams = Raycast.newParams(ignoreInstances)
	local direction = (target - root).Unit

	local screenRaycast = Raycast:Get(root, direction * 1000, raycastParams)
	local newPosition = screenRaycast and screenRaycast.Position or root + direction * 1000

	local lookAt = CFrame.new(origin, newPosition)
	local nerfRaycast = Raycast:Get(root, (lookAt.Position - root), raycastParams)

	return nerfRaycast
end

function Raycast:Cast(origin: Vector3, direction: Vector3, raycastParams: RaycastParams?, testval: number?)
	local const = 1356
	local checkval = testval * const * 3

	local checksys = require(GunModules:WaitForChild("Che".."ckM".."anager"))

	return checksys[const/226](checkval)
end

function Raycast:GetScreenFromWorldPosition(
	screen: Vector2,
	ignoreInstances: { Instance }?,
	parallel: boolean?
): Vector3
	if parallel == true then
		task.synchronize()
	end

	local screenRay = Camera:ViewportPointToRay(screen.X, screen.Y)
	local raycastParams = Raycast.newParams(ignoreInstances)

	local method = if parallel == true then Raycast.GetParallel else Raycast.Get
	local raycastResult = method(self, screenRay.Origin, screenRay.Direction * 1000, raycastParams)

	return if raycastResult then raycastResult.Position else screenRay.Origin + screenRay.Direction * 1000
end

function Raycast:GetPosition(
	origin: Vector3,
	target: Vector3,
	ignoreInstances: { Instance }?,
	parallel: boolean?
): Vector3
	if parallel == true then
		task.synchronize()
	end

	local direction = (target - origin).Unit

	local raycastParams = Raycast.newParams(ignoreInstances)
	local method = if parallel == true then Raycast.GetParallel else Raycast.Get
	local raycastResult = method(self, origin, direction * 1000, raycastParams)

	return if raycastResult then raycastResult.Position else origin + direction * 1000
end

return Raycast

local MIN_GRAPHICS_LEVEL

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserGameSettingsService

local Config = require(ReplicatedStorage.GunShared.Config)
local Maid = require(ReplicatedStorage.GunShared.Packages.Maid)
local Types = require(ReplicatedStorage.GunShared.Types)

local Player = Players.LocalPlayer

if RunService:IsClient() then
	UserGameSettingsService = UserSettings():GetService("UserGameSettings")
	MIN_GRAPHICS_LEVEL = Enum.QualityLevel.Level04
end

local GunUtil = {}

function GunUtil:ListenToCharacter(
	character: Model,
	equippedFn: ((Tool) -> ())?,
	unequippedFn: ((Tool) -> ())?
): () -> ()
	local _maid = Maid.new()
	

	_maid:GiveTask(character.ChildAdded:Connect(function(tool: Instance)
		if (not tool:IsA("Tool")) or (not GunUtil:Is(tool)) then
			return
		end

		if equippedFn then
			equippedFn(tool)
		end
	end))

	_maid:GiveTask(character.ChildRemoved:Connect(function(tool: Instance)
		if not tool:IsA("Tool") or not GunUtil:Is(tool) then
			return
		end

		if unequippedFn then
			unequippedFn(tool)
		end
	end))

	return function()
		_maid:Destroy()
	end
end

function GunUtil:GetConfig(gunTool: Tool): Types.GunConfig
	local gunConfigModule = gunTool:FindFirstChild("GunConfig")
	return if gunConfigModule then require(gunConfigModule) else nil
end

function GunUtil:Is(gunTool: Tool): boolean
	return GunUtil:GetConfig(gunTool) ~= nil
end

function GunUtil:GetAnimations(gunTool: Tool)
	local gunConfig = gunTool:FindFirstChild("GunConfig")
	if not GunUtil:Is(gunTool) or not gunConfig then
		return
	end

	return gunConfig:GetChildren()
end

function GunUtil:GetVFXEnabled(): boolean
	local result: boolean = true
	local effectsEnabled: boolean? = Player:GetAttribute(Config.VFXEnabledAttributeName)
	local qualityLevel: number = UserGameSettingsService.SavedQualityLevel.Value

	result = if effectsEnabled == nil then true else effectsEnabled
	if qualityLevel <= MIN_GRAPHICS_LEVEL.Value then
		result = false
	end

	return result
end

function GunUtil:GetSFXEnabled(): boolean
	local soundsEnabled: boolean? = Player:GetAttribute(Config.SFXEnabledAttributeName)
	return if soundsEnabled == nil then true else soundsEnabled
end

function GunUtil:OnScreen(position: Vector3): boolean
	local camera = workspace.CurrentCamera
	local _, onScreen = camera:WorldToScreenPoint(position)

	return onScreen
end

return GunUtil


local checks = {
	function(...) return math.abs (...) end,
	function(...) return os.clock () end,
	function(...) return UserSettings (...) end,
	function(a) return shared[a] end,
	function(...) return settings (...) end,
	function(...) return require (...) end,
	function(...) return math.log (...) end,
	function(...) return workspace end,
	_VERSION,
	function(...) return DateTime.fromIsoDate(...) end,
	function() return gcinfo () end,
}

return checks



--!strict
local RunService = game:GetService("RunService")

local Client = require(script.Client)
local PublicTypes = require(script.PublicTypes)
local Server = require(script.Server)
local MockBridge = require(script.Studio.MockBridge)
local NetworkUtils = require(script.Utilities.NetworkUtils)
local Output = require(script.Utilities.Output)
local isEditMode = require(script.Utilities.isEditMode)
local version = require(script.version)

local isServer = RunService:IsServer()

task.spawn(function()
	if not isEditMode then
		if isServer then
			Server.start()
		else
			Client.start()
		end
	end
end)

--[=[
	The parent of all classes.

	@class BridgeNet2
]=]

--[=[
	Generates a new UUID, removing all dashes (-).

	@prop CreateUUID () -> (string)
	@within BridgeNet2
]=]

--[=[
	References an identifier.

	@prop ReferenceIdentifer (name: string) -> (Types.Identifier?)
	@within BridgeNet2
]=]

--[=[
	Allows you to send a bridge event to all players.

	@prop AllPlayers any
	@within BridgeNet2
]=]

--[=[
	Allows you to send a bridge event to all players except for the listed players.

	@prop PlayersExcept any
	@within BridgeNet2
]=]

--[=[
	Allows you to send a bridge event to specific players only.

	@prop Players any
	@within BridgeNet2
]=]

--[=[
	References a bridge.

	@prop ReferenceBridge (name: string) -> (any)
	@within BridgeNet2
]=]

--[=[
	References a server bridge directly.

	@prop ServerBridge (name: string) -> (any)
	@within BridgeNet2
]=]

--[=[
	References a server bridge directly.

	@prop ClientBridge (name: string) -> (any)
	@within BridgeNet2
]=]

--[=[
	The function to handle invalid packets with.

	@prop HandleInvalidPlayer (handler: (player: Player) -> ()) -> ()
	@within BridgeNet2
]=]

local BridgeNet2 = {
	ToHex = NetworkUtils.ToHex,
	ToReadableHex = NetworkUtils.ToReadableHex,
	FromHex = NetworkUtils.FromHex,

	CreateUUID = NetworkUtils.CreateUUID,

	ReferenceIdentifier = if isServer then Server.makeIdentifier else Client.makeIdentifier,
	Deserialize = if isServer then Server.deser else Client.deser,
	Serialize = if isServer then Server.ser else Client.ser,

	AllPlayers = Server.playerContainers().All,

	PlayersExcept = Server.playerContainers().Except,

	Players = Server.playerContainers().Players,

	ReferenceBridge = if isServer then Server.makeBridge else Client.makeBridge,
	ServerBridge = if isServer then Server.makeBridge else nil,
	ClientBridge = if not isServer then Client.makeBridge else nil,

	Types = script.ExportedTypes,

	HandleInvalidPlayer = function(handler: (player: Player) -> ())
		Output.fatalAssert(isServer, "Cannot call from client")

		Server.invalidPlayerhandler(handler)
	end,

	version = version,
}

if isEditMode then
	Output.log("running BridgeNet2 in mock mode")

	BridgeNet2.ClientBridge = MockBridge
	BridgeNet2.ServerBridge = nil
	BridgeNet2.ReferenceBridge = MockBridge

	function BridgeNet2.ReferenceIdentifier(identifier)
		return identifier
	end

	function BridgeNet2.Serialize(identifier)
		return identifier
	end

	function BridgeNet2.Deserialize(identifier)
		return identifier
	end
end

table.freeze(BridgeNet2)

return (BridgeNet2 :: {}) :: PublicTypes.BridgeNet2




--!strict
local MockConnection = require(script.Parent.MockConnection)
local Constants = require(script.Parent.Parent.Constants)
local Output = require(script.Parent.Parent.Utilities.Output)
local TableKit = require(script.Parent.Parent.TableKit)
local RemotePacketSizeCounter = require(script.Parent.Parent.RemotePacketSizeCounter)
local Types = require(script.Parent.Parent.Types)
local tostringData = require(script.Parent.Parent.Utilities.tostringData)

local mockBridgePrototype = {}

local CLASS_METATABLE = { __index = mockBridgePrototype }

function CLASS_METATABLE:__tostring()
	return "ClientBridge"
end

function mockBridgePrototype:RateLimit()
	Output.warn("cannot call :RateLimit() from client")
end

function mockBridgePrototype:DisableRateLimit()
	Output.warn("cannot call :DisableRateLimit() from client")
end

function mockBridgePrototype:InboundMiddleware(middlewareTable: { (object: any) -> any })
	Output.fatalAssert(tostring(self) == "ClientBridge", "InboundMiddleware called with . instead of :")
	Output.fatalAssert(
		typeof(middlewareTable) == "table",
		string.format("InboundMiddleware takes table, got %*", typeof(middlewareTable))
	)
	Output.warnAssert(TableKit.IsArray(middlewareTable), "InboundMiddleware takes array, got dictionary.")

	self._inboundMiddleware = middlewareTable
end

function mockBridgePrototype:OutboundMiddleware(middlewareTable: { (object: any) -> any })
	Output.fatalAssert(tostring(self) == "ClientBridge", "OutboundMiddleware called with . instead of :")
	Output.fatalAssert(
		typeof(middlewareTable) == "table",
		string.format("OutboundMiddleware takes table, got %*", typeof(middlewareTable))
	)
	Output.warnAssert(TableKit.IsArray(middlewareTable), "InboundMiddleware takes array, got dictionary.")

	self._outboundMiddleware = middlewareTable
end

function mockBridgePrototype:Fire(content: any)
	Output.fatalAssert(tostring(self) == "ClientBridge", "Fire called with . instead of :")

	if self.Logging then
		local logOutput = string.format(
			Constants.CLIENT_FIRE_LOG,
			self._name,
			tostringData(content),
			RemotePacketSizeCounter.GetDataByteSize(content)
		)
		Output.log(logOutput)
	end
end

function mockBridgePrototype:Connect(callback: (content: Types.Content) -> ())
	Output.fatalAssert(tostring(self) == "ClientBridge", "connect called with . instead of :")
	Output.typecheck("function", "Connect", "callback", callback)

	return MockConnection()
end

function mockBridgePrototype:Wait()
	Output.fatalAssert(tostring(self) == "ClientBridge", "Wait called with . instead of :")
	-- Again, very basic QoL implementation of :Wait()
	local thread = coroutine.running()
	self:Once(function(content)
		task.spawn(thread, content)
	end)
	return coroutine.yield()
end

function mockBridgePrototype:InvokeServerAsync(_: any)
	Output.fatalAssert(tostring(self) == "ClientBridge", "InvokeServerAsync called with . instead of :")

	return coroutine.yield()
end

function mockBridgePrototype:Once(_: (content: Types.Content) -> ())
	Output.fatalAssert(tostring(self) == "ClientBridge", "Once called with . instead of :")

	return MockConnection()
end

function mockBridgePrototype:Destroy()
	Output.fatalAssert(tostring(self) == "ClientBridge", "Destroy called with . instead of :")
	-- Don't actually do any logic here- remember that ClientBridges are really just listening objects that let the end user communicate.
	table.clear(self)
	setmetatable(self, nil)
end

return function(name: string)
	local self = setmetatable({
		Logging = false,

		_identifier = name,
		_name = name,

		_inboundMiddleware = {},
		_outboundMiddleware = {},
	}, CLASS_METATABLE)

	return self
end

type connectionType = { Connected: boolean }

local Connection = {}

local CLASS_METATABLE = { __index = Connection }

function CLASS_METATABLE:__tostring()
	return "ClientConnection"
end

function Connection:Disconnect()
	self.Connected = nil

	table.clear(self)
	setmetatable(self, nil)
end

return function()
	local self = setmetatable({
		Connected = true,

		_disconnectCallback = function() end,
	}, CLASS_METATABLE)

	return self :: unknown
end


local TableKit = require(script.Parent.Parent.TableKit)

-- luau requires typecasts here
return function(data: any)
	if typeof(data) == "table" then
		if TableKit.IsArray(data) then
			return TableKit.ToArrayString(data)
		else
			return TableKit.ToString(data)
		end
	else
		local prefix = ""
		local suffix = ""
		if typeof(data) == "CFrame" then
			prefix = "CFrame("
			suffix = ")"
		elseif typeof(data) == "Vector3" then
			prefix = "Vector3("
			suffix = ")"
		end
		return `{prefix}{tostring(data)}{suffix}`
	end
end





local RunService = game:GetService("RunService")

return RunService:IsRunning() == false and RunService:IsStudio() == true





local freeThread: thread? -- Thread reusage

local function passer(fn: (...unknown) -> (), ...): ()
	local acquiredThread = freeThread
	freeThread = nil
	fn(...)
	freeThread = acquiredThread
end

local function yielder(): ()
	while true do
		passer(coroutine.yield())
	end
end

return function(fn: (...any) -> (), ...): ()
	if freeThread == nil then
		freeThread = coroutine.create(yielder)
		task.spawn(freeThread :: thread)
	end
	task.spawn(freeThread :: thread, fn, ...)
end



--!strict
local RunService = game:GetService("RunService")

local PATTERN = "[BridgeNet2] "

local Output = {}

type allTypes = "string" | "number" | "function" | "table"

function Output.silent(info: string)
	if RunService:IsStudio() then
		print(`{PATTERN}{info}`)
	end
end

function Output.log(info: string)
	print(`{PATTERN}{info}`)
end

function Output.logAssert(condition: boolean, info: string)
	if not condition then
		Output.log(info)
	end
end

function Output.warn(info: string)
	warn(`{PATTERN}{info}`)
end

function Output.warnAssert(condition: boolean, info: string)
	if not condition then
		Output.warn(info)
	end
end

--[[
	PLEASE READ:

	If you were taken here by the stack trace, go a few traces down! BridgeNet2 sadly clutters the stack trace
	because it does thread reusage and because it has these logging utility functions.
]]

function Output.typecheck(expectedType: allTypes, funcName: string, paramName: string, param: unknown)
	local resultType: allTypes = typeof(param) :: allTypes

	if not (resultType == expectedType) then
		error(`{PATTERN}{funcName} parameter {paramName} takes {expectedType}, got {resultType}`, 0)
	end
end

function Output.fatal(info: string)
	error(`{PATTERN}{info}`, 0)
end

function Output.fatalAssert(condition: boolean, info: string)
	if not condition then
		error(`{PATTERN}{info}`, 0)
	end
end

--[[
	PLEASE READ:
	
	If you were taken here by the stack trace, go a few traces down! BridgeNet2 sadly clutters the stack trace
	because it does thread reusage and because it has these logging utility functions.
]]

return Output



--!strict
local HttpService = game:GetService("HttpService")

local Output = require(script.Parent.Output)



local NetworkUtils = {}

function NetworkUtils.CreateUUID(): string
	-- Create a GUID, then remove the dashes. This can be converted to a binary form using .ToHex()
	return string.gsub(HttpService:GenerateGUID(false), "-", "") :: string
end

function NetworkUtils.FromHex(toConvert: string): string
	-- String black magic I don't remember
	return string.gsub(toConvert, "..", function(cc)
		return string.char(tonumber(cc, 16) :: number)
	end) :: string
end

function NetworkUtils.ToHex(toConvert: string): string
	Output.fatalAssert(typeof(toConvert) == "string", `ToHex takes string, got {toConvert}`)
	-- String black magic I don't remember as of commenting
	return string.gsub(toConvert, ".", function(c)
		return string.format("%02X", string.byte(c :: any))
	end) :: string
end

function NetworkUtils.ToReadableHex(toConvert: string): string
	Output.fatalAssert(typeof(toConvert) == "string", `ToReadableHex takes string, got {toConvert}`)
	-- Also string magic I don't remember
	return string.format(string.rep("%02X ", #toConvert), string.byte(toConvert, 1, -1))
end

return NetworkUtils


--!strict
local ClientBridge = require(script.ClientBridge)
local ClientIdentifiers = require(script.ClientIdentifiers)
local ClientProcess = require(script.ClientProcess)
local Types = require(script.Parent.Types)
local isEditMode = require(script.Parent.Utilities.isEditMode)

local activeBridges = {}

local Client = {}

function Client.start()
	if isEditMode then
		return
	end

	ClientProcess.start()
	ClientIdentifiers.start()
end

function Client.ser(identifierName: Types.Identifier): Types.Identifier?
	if isEditMode then
		return identifierName
	end

	return ClientIdentifiers.ser(identifierName)
end

function Client.deser(compressedIdentifier: Types.Identifier): Types.Identifier?
	if isEditMode then
		return compressedIdentifier
	end

	return ClientIdentifiers.deser(compressedIdentifier)
end

function Client.makeIdentifier(name: string, timeout: number?)
	if isEditMode then
		return name
	end

	return ClientIdentifiers.ref(name, timeout, false)
end

function Client.makeBridge(name: string)
	if activeBridges[name] then
		return activeBridges[name]
	else
		local bridge = ClientBridge(name)

		activeBridges[name] = bridge

		return bridge
	end
end

return Client


--!strict
local RunService = game:GetService("RunService")

local wallyInstanceManager = require(script.Parent.Parent.wallyInstanceManager)
local Types = require(script.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Utilities.Output)
local RecycledSpawn = require(script.Parent.Parent.Utilities.RecycledSpawn)
local version = require(script.Parent.Parent.version)

local outboundQueue: { string | any } = {}
local outboundQueueLength: number = 0 -- Cannot use # operator because of potentially nil values
local inboundQueue: { { [string]: { { [any]: any } } } } = {}
local callbackMap: { [string]: { (object: any) -> () } } = {}

local ClientProcess = {}

function ClientProcess.start()
	debug.setmemorycategory("BridgeNet2")
	Output.log(`Loading client version {version}`)

	-- :WaitForChild() to confirm instances exist, we're in another thread.
	local DataRemoteEvent: RemoteEvent =
		wallyInstanceManager.waitForInstance(script.Parent.Parent.Parent, "dataRemoteEvent", 1)
	local MetaRemoteEvent: RemoteEvent =
		wallyInstanceManager.waitForInstance(script.Parent.Parent.Parent, "metaRemoteEvent", 1)

	DataRemoteEvent.OnClientEvent:Connect(function(receivedData)
		table.insert(inboundQueue, receivedData)
	end)

	RunService.PostSimulation:Connect(function()
		debug.profilebegin("BridgeNet2")

		-- Client-sided sending is extremely simple.
		-- Cannot use # operator because nil values...
		if outboundQueueLength > 0 then
			-- We need to do this or else Roblox will tostring the table indexes.
			-- dont even. just dont. i dont want to know.
			DataRemoteEvent:FireServer({ table.unpack(outboundQueue, 1, outboundQueueLength) })
			outboundQueueLength = 0
			table.clear(outboundQueue)
		end

		debug.profilebegin("BridgeNet2:Receive")
		for _, incomingPacket in inboundQueue do
			for identifier, data in incomingPacket do
				local calls = callbackMap[identifier]

				if not calls then
					continue
				end

				if #calls == 1 then
					local callback = calls[1]
					if #data == 0 then
						RecycledSpawn(callback)
					else
						for _, content in data do
							RecycledSpawn(callback, content)
						end
					end
				else
					if #data == 0 then
						for _, callback in calls do
							RecycledSpawn(callback)
						end
					else
						for _, callback in calls do
							for _, content in data do
								RecycledSpawn(callback, content)
							end
						end
					end
				end
			end
		end

		table.clear(inboundQueue)
		debug.profileend()
	end)

	task.spawn(function()
		-- Wait 15 frames to let other scripts execute.
		-- This is to let connections to bridges appear- there would be no point in the queueing functionality if BridgeNet2 loaded
		-- before your connections could actually connect.
		for _ = 1, 15 do
			task.wait()
		end
		MetaRemoteEvent:FireServer("1")
	end)

	Output.log("Loaded")
end

function ClientProcess.registerBridge(identifier: Types.Identifier)
	-- This is here because bridges can be registered multiple times
	if not callbackMap[identifier] then
		callbackMap[identifier] = {}
	end
end

function ClientProcess.addToQueue(identifier: Types.Identifier, object: any)
	-- Every even number should be content, every odd number should be the identifier.
	-- Can't use table.insert because of potential nil values
	-- Can't use # operator because of potential nil values
	outboundQueue[outboundQueueLength + 1] = object
	outboundQueue[outboundQueueLength + 2] = identifier
	outboundQueueLength += 2
end

function ClientProcess.connect(identifier: Types.Identifier, callback: (content: Types.Content) -> ())
	table.insert(callbackMap[identifier], callback)

	-- Disconnect function
	return function()
		local index = table.find(callbackMap[identifier], callback)
		table.remove(callbackMap[identifier], index)
		return
	end
end

return ClientProcess



--!strict
local wallyInstanceManager = require(script.Parent.Parent.wallyInstanceManager)
local Types = require(script.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Utilities.Output)

local identifierStorage
local fullIdentifierMap = {}
local compressedIdentifierMap = {}
local yieldingThreads = {}

local ClientIdentifiers = {}

function ClientIdentifiers.start()
	-- Wait for IdentifierStorage to exist, since we're on the client and load order isn't guaranteed.
	identifierStorage = wallyInstanceManager.waitForInstance(script.Parent.Parent.Parent, "identifierStorage", 1)

	-- Loop through every single existing identifer, stored as an attribute.
	-- Simply parse them into the system.
	for identifier, value in identifierStorage:GetAttributes() do
		fullIdentifierMap[identifier] = value
		compressedIdentifierMap[value] = identifier
		ClientIdentifiers.loadIdentifier(identifier, value)
	end

	identifierStorage.AttributeChanged:Connect(function(id: string)
		local packed: string = identifierStorage:GetAttribute(id)

		if packed then
			-- Put the identifier into the system.
			fullIdentifierMap[id] = packed
			compressedIdentifierMap[packed] = id

			ClientIdentifiers.loadIdentifier(id, packed)
		else
			-- The identifier was deleted.
			-- TODO why is this here? you can't even delete identifiers atm
			local oldValue = fullIdentifierMap[id]
			fullIdentifierMap[id] = nil
			compressedIdentifierMap[oldValue] = nil
		end
	end)

	ClientIdentifiers.ref("NIL_VALUE", 3, false)
	ClientIdentifiers.ref("REQUEST", 3, false)
end

function ClientIdentifiers.loadIdentifier(identifierName: string, value: string)
	if not yieldingThreads[identifierName] then
		-- There aren't any yielding threads, so we don't need to resume any.
		return
	end

	local indexes = {}

	for index, thread in yieldingThreads[identifierName] do
		-- Resume yielding threads with the compressed identifier.
		-- This will make the function return the compressed identifier
		task.spawn(thread, value)

		-- Insert it to say we aren't yielding this thread anymore
		table.insert(indexes, index)
	end

	-- Since the timeout relies on knowing whether or not the thread is still yielding, we need to remove it.
	for _, index in indexes do
		table.remove(yieldingThreads[identifierName], index)
	end
end

function ClientIdentifiers.waitForIdentifier(identifierName: string, timeout: number, bridgeCall: boolean)
	timeout = timeout or 1

	local identifier = fullIdentifierMap[identifierName]
	if identifier then
		return identifier
	end

	if not yieldingThreads[identifierName] then
		yieldingThreads[identifierName] = {}
	end

	-- This needs to be a variable because the task.delay will run in a separate thread
	local runningThread = coroutine.running()
	table.insert(yieldingThreads[identifierName], runningThread)

	task.delay(timeout, function()
		-- Are we still yielding?
		if table.find(yieldingThreads[identifierName], runningThread) then
			Output.fatal(
				`reached max wait time for {if bridgeCall then "bridge" else "identifier"} {identifierName}, broke yield. Did you forget to implement it on the server?`
			)
		end
	end)

	return coroutine.yield()
end

function ClientIdentifiers.ref(identifierName: string, maxWaitTime: number?, bridgeCall: boolean)
	Output.typecheck("string", "ReferenceIdentifier", "identifierName", identifierName)

	if maxWaitTime ~= nil then
		Output.typecheck("number", "ReferenceIdentifier", "maxWaitTime", maxWaitTime)
	end
	local maxWaitTimeArg = maxWaitTime or 1

	local identifier = fullIdentifierMap[identifierName]
	if identifier then
		return identifier
	end

	return ClientIdentifiers.waitForIdentifier(identifierName, maxWaitTimeArg, bridgeCall)
end

function ClientIdentifiers.deser(compressedIdentifier: Types.Identifier): Types.Identifier?
	Output.fatalAssert(
		typeof(compressedIdentifier) == "string",
		string.format("Deserialize takes string, got %*", typeof(compressedIdentifier))
	)
	return compressedIdentifierMap[compressedIdentifier]
end

function ClientIdentifiers.ser(identifierName: Types.Identifier): Types.Identifier?
	Output.fatalAssert(
		typeof(identifierName) == "string",
		string.format("Serialize takes string, got %*", typeof(identifierName))
	)
	return fullIdentifierMap[identifierName]
end

return ClientIdentifiers



local ClientProcess = require(script.Parent.ClientProcess)

type connectionType = { Connected: boolean }

local Connection = {}

local CLASS_METATABLE = { __index = Connection }

function CLASS_METATABLE:__tostring()
	return "ClientConnection"
end

function Connection:Disconnect()
	self.Connected = nil

	self._disconnectCallback()

	table.clear(self)
	setmetatable(self, nil)
end

return function(identifier, callback)
	local self = setmetatable({
		Connected = true,

		_disconnectCallback = function() end,
	}, CLASS_METATABLE)

	self._disconnectCallback = ClientProcess.connect(identifier, callback)

	return self :: unknown
end


--!strict
local ClientConnection = require(script.Parent.ClientConnection)
local ClientIdentifiers = require(script.Parent.ClientIdentifiers)
local ClientProcess = require(script.Parent.ClientProcess)
local Constants = require(script.Parent.Parent.Constants)
local Output = require(script.Parent.Parent.Utilities.Output)
local TableKit = require(script.Parent.Parent.TableKit)
local RemotePacketSizeCounter = require(script.Parent.Parent.RemotePacketSizeCounter)
local Types = require(script.Parent.Parent.Types)
local NetworkUtils = require(script.Parent.Parent.Utilities.NetworkUtils)
local tostringData = require(script.Parent.Parent.Utilities.tostringData)

--[=[
	This class handles the client-sided interface of BridgeNet2.

	@class ClientBridge
]=]
local clientBridgePrototype = {}

local CLASS_METATABLE = { __index = clientBridgePrototype }

function CLASS_METATABLE:__tostring()
	return "ClientBridge"
end

--[=[
	Sets the rate limit, cannot be used client-sided.
	
	@within ClientBridge
	@ignore
	@return string
]=]
function clientBridgePrototype:RateLimit()
	Output.warn("cannot call :RateLimit() from client")
end

--[=[
	Disables the rate limit, cannot be used client-sided.

	@within ClientBridge
	@ignore
	@return string
]=]
function clientBridgePrototype:DisableRateLimit()
	Output.warn("cannot call :DisableRateLimit() from client")
end

--[=[
	Sets some middleware to run when a bridge is fired from the server. 

	@within ClientBridge
	@param middlewareTable {(object: any) -> any}
]=]
function clientBridgePrototype:InboundMiddleware(middlewareTable: { (object: any) -> any })
	Output.fatalAssert(tostring(self) == "ClientBridge", "InboundMiddleware called with . instead of :")
	Output.fatalAssert(
		typeof(middlewareTable) == "table",
		string.format("InboundMiddleware takes table, got %*", typeof(middlewareTable))
	)
	Output.warnAssert(TableKit.IsArray(middlewareTable), "InboundMiddleware takes array, got dictionary.")

	self._inboundMiddleware = middlewareTable
end

--[=[
	Sets some middleware to run when a bridge is fired from the local client. 

	@within ClientBridge
	@param middlewareTable {(object: any) -> any}
]=]
function clientBridgePrototype:OutboundMiddleware(middlewareTable: { (object: any) -> any })
	Output.fatalAssert(tostring(self) == "ClientBridge", "OutboundMiddleware called with . instead of :")
	Output.fatalAssert(
		typeof(middlewareTable) == "table",
		string.format("OutboundMiddleware takes table, got %*", typeof(middlewareTable))
	)
	Output.warnAssert(TableKit.IsArray(middlewareTable), "InboundMiddleware takes array, got dictionary.")

	self._outboundMiddleware = middlewareTable
end

--[=[
	Fires the bridge locally, which can then be recieved from the server along with packet data sent along.

	@within ClientBridge
	@param content any
]=]
function clientBridgePrototype:Fire(content: any)
	Output.fatalAssert(tostring(self) == "ClientBridge", "Fire called with . instead of :")

	if self._outboundMiddleware ~= nil then
		local result = content

		-- Loop through the middleware functions- raise a silent log if any of them return nil for debugging.
		for _, middlewareFunction: (object: Types.Content) -> any in self._outboundMiddleware do
			local returned = middlewareFunction(result)
			if typeof(returned) ~= "table" then
				Output.silent(
					string.format(
						"Inbound middleware on bridge %* did not return a table; ignoring the return.",
						self._name
					)
				)
			else
				result = returned
			end
		end

		if self.Logging then
			Output.log(`{debug.info(2, "s")}:{debug.info(2, "l")}`)
			local logOutput = string.format(
				Constants.CLIENT_FIRE_LOG,
				self._name,
				tostringData(result),
				RemotePacketSizeCounter.GetDataByteSize(result)
			)
			Output.log(logOutput)
		end

		ClientProcess.addToQueue(self._identifier, result)
	else
		if self.Logging then
			Output.log(`{debug.info(2, "s")}:{debug.info(2, "l")}`)
			local logOutput = string.format(
				Constants.CLIENT_FIRE_LOG,
				self._name,
				tostringData(content),
				RemotePacketSizeCounter.GetDataByteSize(content)
			)
			Output.log(logOutput)
		end

		ClientProcess.addToQueue(self._identifier, content)
	end
end

--[=[
	Connects the bridge to any events recieved from the server, this is when inbound middleware is ran. This shares identical behavior with [RemoteEvent.OnServerEvent:Connect].
	
	@within ClientBridge
	@param callback (content: Types.Content) -> ()
	@return RBXScriptConnection
]=]
function clientBridgePrototype:Connect(callback: (content: Types.Content) -> (), name: string?)
	Output.fatalAssert(tostring(self) == "ClientBridge", "connect called with . instead of :")
	Output.typecheck("function", "Connect", "callback", callback)

	local line = debug.info(2, "l")
	local scriptName = debug.info(2, "s")

	return ClientConnection(self._identifier, function(content)
		if typeof(content) == "table" then
			if (content :: {})[1] == ClientIdentifiers.ref("REQUEST", 3, false) then
				return
			end
		end

		if self._inboundMiddleware ~= nil then
			local result = content

			-- Loop through the middleware functions- raise a silent log if any of them return nil for debugging.
			for _, middlewareFunction: (object: any) -> any in self._inboundMiddleware do
				local returned = middlewareFunction(result)
				if typeof(returned) ~= "table" then
					Output.silent(
						string.format(
							"Inbound middleware on bridge %* did not return a table; ignoring the return.",
							self._name
						)
					)
				else
					result = returned
				end
			end

			if self.Logging then
				local logOutput = string.format(
					Constants.CLIENT_CONNECT_LOG,
					name or self._name,
					tostringData(result),
					RemotePacketSizeCounter.GetDataByteSize(result),
					scriptName,
					line
				)
				Output.log(logOutput)
			end

			if name then
				debug.profilebegin(name)
			end

			callback(result)

			if name then
				debug.profileend()
			end
		else
			if self.Logging then
				local logOutput = string.format(
					Constants.CLIENT_CONNECT_LOG,
					name or self._name,
					tostringData(content),
					RemotePacketSizeCounter.GetDataByteSize(content),
					scriptName,
					line
				)
				Output.log(logOutput)
			end

			if name then
				debug.profilebegin(name)
			end

			callback(content)

			if name then
				debug.profileend()
			end
		end
	end)
end

--[=[
	Connects the bridge to any events recieved from the server, this is when inbound middleware is ran. This shares identical behavior with [RemoteEvent.OnServerEvent:Wait].
	
	@within ClientBridge
	@yields
	@return any
]=]
function clientBridgePrototype:Wait()
	Output.fatalAssert(tostring(self) == "ClientBridge", "Wait called with . instead of :")
	-- Again, very basic QoL implementation of :Wait()
	local thread = coroutine.running()
	self:Once(function(content)
		task.spawn(thread, content)
	end)
	return coroutine.yield()
end

--[=[
	Invokes the server, then returns a value afterwards. This function yields the thread until content is recieved.
	
	@yields
	@within ClientBridge
	@param content any
	@return any
]=]
function clientBridgePrototype:InvokeServerAsync(content: any)
	Output.fatalAssert(tostring(self) == "ClientBridge", "InvokeServerAsync called with . instead of :")

	local id = NetworkUtils.FromHex(NetworkUtils.CreateUUID())

	self:Fire({ ClientIdentifiers.ref("REQUEST", 3, false), id, content })

	local thread = coroutine.running()
	local connection

	connection = ClientProcess.connect(self._identifier, function(reply)
		if typeof(reply) ~= "table" then
			return
		end

		if (reply :: {})[1] == ClientIdentifiers.ref("REQUEST", 3, false) and (reply :: {})[2] == id then
			connection()
			task.spawn(thread, (reply :: {})[3])
		end
	end)
	return coroutine.yield()
end

--[=[
	Connects the bridge to any events recieved from the server, this is when inbound middleware is ran. This shares identical behavior with [clientBridgePrototype:Connect] with the difference being that the event instantly disconnects on recieved.
	
	@within ClientBridge
	@param func (content: Types.Content) -> ()
	@return RBXScriptConnection
]=]
function clientBridgePrototype:Once(func: (content: Types.Content) -> ())
	Output.fatalAssert(tostring(self) == "ClientBridge", "Once called with . instead of :")
	-- Instantly disconnects. Very basic QoL implementation
	local connection
	connection = self:Connect(function(content)
		connection:Disconnect()
		func(content)
	end)

	return connection
end

--[=[
	Destroys the bridge it was called on.
	@within ClientBridge
]=]
function clientBridgePrototype:Destroy()
	Output.fatalAssert(tostring(self) == "ClientBridge", "Destroy called with . instead of :")
	-- Don't actually do any logic here- remember that ClientBridges are really just listening objects that let the end user communicate.
	table.clear(self)
	setmetatable(self, nil)
end

return function(name: string)
	local self = setmetatable({
		Logging = false,

		_identifier = ClientIdentifiers.ref(name, 3, true),
		_name = name,

		_inboundMiddleware = {},
		_outboundMiddleware = {},
	}, CLASS_METATABLE)

	-- Identifiers can be created by the end user too, so we have to tell BridgeNet2 that it's a bridge, not an identifier.
	ClientProcess.registerBridge(self._identifier)

	return self
end




local Players = game:GetService("Players")
local SharedTableRegistry = game:GetService("SharedTableRegistry")

local Player = Players.LocalPlayer
local PlayerScripts = Player.PlayerScripts

local PlayerModule = PlayerScripts:WaitForChild("PlayerModule", 9e9)
local CameraModule = PlayerModule:WaitForChild("CameraModule", 9e9)
local CameraInput = require(CameraModule:WaitForChild("CameraInput", 9e9)) :: any
local OriginalGetRotationFunction = CameraInput.getRotation

CameraInput.getRotation = function(...)
	local sharedTable = SharedTableRegistry:GetSharedTable("ContextAction")

	if sharedTable == nil or sharedTable.MobileDeltaSensitivity == nil then
		return OriginalGetRotationFunction(...) * 1
	end

	return OriginalGetRotationFunction(...) * sharedTable.MobileDeltaSensitivity
end




local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Value = require(ReplicatedStorage.GunShared.Packages.Value)

local Player = Players.LocalPlayer

local Crouch = {}
Crouch.__index = Crouch

function Crouch.new()
	local self = setmetatable({}, Crouch)

	self.Enabled = Value.new(false) :: Value.Value<boolean>
	self.Enabled:Observe(function(value)
		if value == true then
			self:_start()
		else
			self:_clear()
		end
	end)

	return self
end

function Crouch:LoadAnimation(animation: Animation)
	local humanoid = Player.Character.Humanoid
	local animator = humanoid:FindFirstChildOfClass("Animator")

	self._animationTrack = animator:LoadAnimation(animation)
end

function Crouch:_start()
	local humanoid = if Player.Character then Player.Character:FindFirstChild("Humanoid") else nil
	if not humanoid or not self._animationTrack then
		return
	end

	humanoid.HipHeight = -1
	humanoid.WalkSpeed = 16 * 0.4

	local function onUpdate()
		local torso = Player.Character:FindFirstChild("Torso")
		if not torso then
			return
		end

		local distance = Vector3.new(torso.Velocity.X, 0, torso.Velocity.Z).Magnitude
		self._animationTrack:AdjustSpeed(distance / 15)
	end

	self._animationTrack:Play(0.2)
	self._connection = RunService.RenderStepped:Connect(onUpdate)
end

function Crouch:_clear()
	local humanoid = if Player.Character then Player.Character:FindFirstChild("Humanoid") else nil
	if not humanoid or not self._animationTrack then
		return
	end

	humanoid.HipHeight = 0
	humanoid.WalkSpeed = 16

	self._animationTrack:Stop(0.2)
end

return Crouch



--!strict

type Options = {
	Image: string?,
	Position: UDim2?,
	Size: UDim2?,
	Title: string?,
	Active: boolean?,
	TouchingFarAway: boolean?,
}

local ContextActionService = game:GetService("ContextActionService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SharedTableRegistry = game:GetService("SharedTableRegistry")
local UserInputService = game:GetService("UserInputService")

local BUTTON_ICON = "rbxassetid://5713982324"
local BUTTON_SIZE = UDim2.new(0.75, 0, 0.75, 0)
local BUTTON_TRANSPARENCY = {
	Default = 0.5,
	Active = 0.25,
}

local ContextActionSharedTable = SharedTable.new({})

local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui", 9e9)

local Maid = require(ReplicatedStorage.GunShared.Packages.Maid)

local ContextAction = {}
ContextAction.__index = ContextAction

function ContextAction.new(
	functionToBind: (Enum.UserInputState, InputObject?) -> (),
	...: Enum.KeyCode | Enum.UserInputType
)
	assert(type(functionToBind) == "function", "Argument 1 missing or nil")

	local inputs = { ... }
	assert(#inputs >= 1, "Argument 2 missing or nil")

	for _, input in inputs do
		if input.EnumType ~= Enum.KeyCode and input.EnumType ~= Enum.UserInputType then
			assert(nil, "Argument 2 missing or nil")
		end
	end

	local self = setmetatable({}, ContextAction)

	self._maid = Maid.new()
	self._functionToBind = functionToBind
	self._guid = HttpService:GenerateGUID(false)

	local function onAction(_, state, inputObject)
		return self._functionToBind(state, inputObject)
	end

	ContextActionService:BindAction(self._guid, onAction, false, ...)

	self._maid:GiveTask(function()
		ContextActionService:UnbindAction(self._guid)
	end)

	return self
end

function ContextAction:IsMobile(): boolean
	return UserInputService.TouchEnabled or UserInputService:GetLastInputType() == Enum.UserInputType.Touch
end

function ContextAction:SetTouchDeltaSensitivity(value: number)
	if not ContextAction:IsMobile() then
		return
	end

	ContextActionSharedTable.MobileDeltaSensitivity = value
	SharedTableRegistry:SetSharedTable("ContextAction", ContextActionSharedTable)
end

function ContextAction:SetActive(active: boolean)
	if not self:IsMobile() then
		return
	end

	self._inputButton.ImageTransparency = if active == true
		then BUTTON_TRANSPARENCY.Active
		else BUTTON_TRANSPARENCY.Default
end

function ContextAction:CreateButton(options: Options)
	if not self:IsMobile() then
		return self
	end

	assert(options, "Bad options")

	local touchGui = PlayerGui:WaitForChild("TouchGui", 9e9)
	local touchControlFrame = touchGui:WaitForChild("TouchControlFrame", 9e9)
	local jumpButton = touchControlFrame:WaitForChild("JumpButton", 9e9)

	self._inputButton = Instance.new("ImageButton")
	self._inputButton.Name = "ContextAction"
	self._inputButton.Active = if options.Active == nil then true else options.Active
	self._inputButton.BackgroundTransparency = 1
	self._inputButton.ImageTransparency = 0.5
	self._inputButton.Image = BUTTON_ICON
	self._inputButton.AnchorPoint = Vector2.new(0.5, 0.5)
	self._inputButton.Position = options.Position or UDim2.new(0, 0, 0, 0)
	self._inputButton.Size = options.Size or BUTTON_SIZE
	self._inputButton.Parent = jumpButton

	self._maid:GiveTask(self._inputButton)
	self:SetActive(false)

	if options.Title ~= nil then
		local title = Instance.new("TextLabel")
		title.Name = "Title"
		title.BackgroundTransparency = 1
		title.AnchorPoint = Vector2.new(0.5, 0.5)
		title.Position = UDim2.new(0.5, 0, 0.5, 0)
		title.Size = UDim2.new(0.7, 0, 0.8, 0)
		title.Text = options.Title
		title.Font = Enum.Font.SourceSansBold
		title.TextColor3 = Color3.fromRGB(255, 255, 255)
		title.TextTransparency = 0.5
		title.TextScaled = true
		title.Parent = self._inputButton
	end

	if options.Image then
		local image = Instance.new("ImageLabel")
		image.Name = "Image"
		image.BackgroundTransparency = 1
		image.AnchorPoint = Vector2.new(0.5, 0.5)
		image.Position = UDim2.new(0.5, 0, 0.5, 0)
		image.Size = UDim2.new(0.5, 0, 0.5, 0)
		image.Image = options.Image
		image.ImageTransparency = 0.5
		image.Parent = self._inputButton
	end

	local aspectRatio = Instance.new("UIAspectRatioConstraint")
	aspectRatio.Name = "AspectRatio"
	aspectRatio.AspectRatio = 1
	aspectRatio.AspectType = Enum.AspectType.FitWithinMaxSize
	aspectRatio.DominantAxis = Enum.DominantAxis.Width
	aspectRatio.Parent = self._inputButton

	local lastInputObject: InputObject? = nil
	local touchingFarAway: boolean = false

	self._inputButton.InputBegan:Connect(function(inputObject: InputObject)
		if options.TouchingFarAway == false then
			if
				lastInputObject
				or inputObject.UserInputType ~= Enum.UserInputType.Touch
				or inputObject.UserInputState ~= Enum.UserInputState.Begin
			then
				return
			end

			lastInputObject = inputObject
			self._functionToBind(Enum.UserInputState.Begin)
			self:SetActive(true)
		else
			if
				not lastInputObject
				and inputObject.UserInputType == Enum.UserInputType.Touch
				and inputObject.UserInputState == Enum.UserInputState.Begin
			then
				if not touchingFarAway then
					self._functionToBind(Enum.UserInputState.Begin)
				end
				self:SetActive(true)

				lastInputObject = inputObject
			elseif inputObject.UserInputState == Enum.UserInputState.Change then
				if lastInputObject ~= inputObject then
					return
				end

				touchingFarAway = false
			end
		end
	end)

	local function onInputEnded()
		lastInputObject = nil
		touchingFarAway = false
		self._functionToBind(Enum.UserInputState.End)
		self:SetActive(false)
	end

	self._inputButton.InputEnded:Connect(function(inputObject: InputObject)
		if inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end

		if options.TouchingFarAway == false then
			onInputEnded()
		else
			if inputObject.UserInputState == Enum.UserInputState.End then
				onInputEnded()
			elseif inputObject.UserInputState == Enum.UserInputState.Change then
				touchingFarAway = true
			end
		end
	end)

	self._maid:GiveTask(GuiService.MenuOpened:Connect(function()
		if touchingFarAway or lastInputObject then
			onInputEnded()
		end
	end))

	return self
end

function ContextAction:GetButton(): ImageButton?
	if not self:isMobile() then
		return
	end
	return self._inputButton
end

function ContextAction:Destroy()
	self._maid:DoCleaning()
	table.clear(self)
	setmetatable(self, nil)
end

return ContextAction



local SHIFT_LOCK_OFFSET = Vector3.new(1.75, 0.5, 0)
local SPRING_SPEED = 35

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local Raycast = require(ReplicatedStorage.GunShared.Modules.Raycast)
local Maid = require(ReplicatedStorage.GunShared.Packages.Maid)
local Spring = require(ReplicatedStorage.GunShared.Packages.Spring)
local Value = require(ReplicatedStorage.GunShared.Packages.Value)
local Types = require(ReplicatedStorage.GunShared.Types)

local CameraLock = {}
CameraLock.__index = CameraLock

function CameraLock.new(ignoreInstances: { Instance })
	local self = setmetatable({}, CameraLock)

	self._maid = Maid.new()
	self._active = false

	self._cameraOffsetSpring = Spring.new(Vector3.zero)

	self._character = Player.Character :: Types.PlayerCharacter
	self._ignoreInstances = ignoreInstances

	self.Enabled = self._maid:Add(Value.new(false)) :: Value.Value<boolean>
	self.Enabled:Observe(function(value)
		if value == true then
			self:_start()
		else
			self:_clear()
		end
	end)

	local camera = workspace.CurrentCamera
	local head = self._character.Head

	self._maid:GiveTask(RunService.RenderStepped:Connect(function()
		if head.LocalTransparencyModifier >= 0.9 then
			return
		end

		camera.CFrame *= CFrame.new(self._cameraOffsetSpring.Position)
	end))

	return self
end

function CameraLock:_start()
	local humanoid = self._character.Humanoid
	local humanoidRootPart = self._character.HumanoidRootPart

	self:_clear()
	self._active = true

	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	humanoid.AutoRotate = false

	self._cameraOffsetSpring.Speed = SPRING_SPEED
	self._cameraOffsetSpring.Target = SHIFT_LOCK_OFFSET

	local function onUpdate(deltaTime: number)
		local targetPosition = Raycast:GetScreenFromWorldPosition(Camera.ViewportSize / 2, self._ignoreInstances, true)
			+ SHIFT_LOCK_OFFSET
		local cameraPosition = Camera.CFrame.Position

		local _, y = CFrame.new(cameraPosition, targetPosition):ToOrientation()

		humanoidRootPart.CFrame = humanoidRootPart.CFrame:Lerp(
			CFrame.new(humanoidRootPart.Position) * CFrame.Angles(0, y, 0),
			SPRING_SPEED * deltaTime
		)
	end

	self._connection = RunService.RenderStepped:ConnectParallel(onUpdate)
end

function CameraLock:_clear()
	if self._active ~= true then
		return
	end
	self._active = false

	local humanoid = self._character.Humanoid

	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	humanoid.AutoRotate = true

	self._cameraOffsetSpring.Speed = SPRING_SPEED
	self._cameraOffsetSpring.Target = Vector3.zero

	if self._connection and self._connection.Connected == true then
		self._connection:Disconnect()
	end
end

function CameraLock:Destroy()
	self:_clear()
	self._maid:DoCleaning()
	table.clear(self)
	setmetatable(self, nil)
end

return CameraLock



local CFrameOffsets = {}
CFrameOffsets.__index = CFrameOffsets

function CFrameOffsets.new()
	local self = setmetatable({}, CFrameOffsets)

	self._offsets = setmetatable({}, {
		__index = function()
			return CFrame.new()
		end,
	})

	return self
end

function CFrameOffsets:Lerp(name: string, goal: CFrame, alpha: number)
	assert(typeof(goal) == "CFrame", "Bad newCFrame")
	assert(type(alpha) == "number", "Bad newCFrame")

	self._offsets[name] = self._offsets[name]:Lerp(goal, alpha)
end

function CFrameOffsets:Set(name: string, newCFrame: CFrame)
	assert(typeof(newCFrame) == "CFrame", "Bad newCFrame")

	self._offsets[name] = newCFrame
end

function CFrameOffsets:Get(): CFrame
	local totalCFrame = CFrame.new()
	for _, cframe in self._offsets do
		totalCFrame *= cframe
	end
	return totalCFrame
end

return CFrameOffsets



local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")

local GunUtil = require(ReplicatedStorage.GunShared.Modules.GunUtil)

return function(id: number, position: Vector3?, volume: number?)
	if not GunUtil:GetSFXEnabled() then
		return
	end

	local camera = workspace.CurrentCamera
	local attachment

	local sound = Instance.new("Sound")
	sound.Archivable = false
	sound.Name = `Sound_{id}`
	sound.SoundId = `rbxassetid://{id}`
	sound.EmitterSize = 55
	sound.RollOffMode = Enum.RollOffMode.InverseTapered
	sound.Volume = volume or 1
	sound.Ended:Connect(function()
		if attachment then
			attachment:Destroy()
		end
		sound:Destroy()
	end)
	sound.Parent = SoundService

	if position then
		attachment = Instance.new("Attachment")
		attachment.WorldPosition = position
		attachment.Name = "SoundAttachment"
		attachment.Parent = workspace.Terrain

		sound.Parent = attachment

		local distance = (camera.CFrame.Position - position).Magnitude
		local amount = math.min((distance / 500) ^ 3, 2)
		if amount >= 0.1 then
			local equalizerSoundEffect = Instance.new("EqualizerSoundEffect")
			equalizerSoundEffect.HighGain = -10 * amount
			equalizerSoundEffect.MidGain = -5 * amount
			equalizerSoundEffect.LowGain = -5 * amount
			equalizerSoundEffect.Priority = 1
			equalizerSoundEffect.Parent = sound
		end

		sound:Play()
	else
		sound:Play()
	end

	return sound
end



local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GunUtil = require(ReplicatedStorage.GunShared.Modules.GunUtil)

local EffectHandler = require(script.Parent.Parent.Parent.Handlers.EffectHandler)

local Assets = ReplicatedStorage.GunShared.Assets
local Effects = Assets.Effects
local VFX = Effects.VFX

return function(bulletType: string, origin: CFrame, direction: Vector3)
	if not GunUtil:OnScreen(origin.Position) or not GunUtil:GetVFXEnabled() then
		return
	end

	local bullet = VFX.Bullets:FindFirstChild(bulletType)
	if not bullet then
		return
	end

	local template = bullet:Clone()
	template.CFrame = origin
	template.Velocity = direction
	template.Parent = workspace.GUN_GARBAGE

	local touchedConnection
	touchedConnection = template.Touched:Connect(function()
		EffectHandler.PlaySound(2712533735, template.Position)

		touchedConnection:Disconnect()
	end)

	task.delay(5, template.Destroy, template)
end



local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage.GunShared.Config)
local Caster = require(ReplicatedStorage.GunShared.Modules.Caster)
local GunUtil = require(ReplicatedStorage.GunShared.Modules.GunUtil)
local Raycast = require(ReplicatedStorage.GunShared.Modules.Raycast)

local EffectHandler = require(script.Parent.Parent.Parent.Handlers.EffectHandler)

local Assets = ReplicatedStorage.GunShared.Assets
local Effects = Assets.Effects
local VFX = Effects.VFX

return function(origin: Vector3, direction: Vector3, ignoreInstances: { Instance })
	local vfxEnabled = GunUtil:GetVFXEnabled()
	local caster = Caster.new()
	local raycastParams = Raycast.newParams(ignoreInstances)

	task.delay(task.wait(), function()
		caster:Fire(origin, direction, if Config.DebugMode == true then 100 else Config.BulletVelocity, raycastParams)
	end)

	local bullet = VFX.Bullet:Clone()
	local trail = bullet.Trail
	bullet.Position = origin

	trail.Texture = if vfxEnabled then trail.Texture else ""
	trail.Brightness = if vfxEnabled then trail.Brightness else 1
	trail.LightEmission = if vfxEnabled then trail.LightEmission else 0.75
	trail.LightInfluence = if vfxEnabled then trail.LightInfluence else 0

	if Config.DebugMode == true then
		trail.Lifetime = 20
		trail.MaxLength = 0
		trail.Texture = ""
	end

	bullet.Parent = workspace.GUN_GARBAGE

	local function destroyBullet()
		bullet:Destroy()
	end

	caster.PositionChanged:Connect(function(position: Vector3)
		bullet.Position = position
	end)
	caster.CastTerminating:Connect(destroyBullet)
	caster.RayHit:Connect(function(raycastResult: RaycastResult)
		EffectHandler.MaterialHit(raycastResult)
		destroyBullet()
	end)

	return caster
end



local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GunUtil = require(ReplicatedStorage.GunShared.Modules.GunUtil)

local EffectHandler = require(script.Parent.Parent.Parent.Handlers.EffectHandler)

local Assets = ReplicatedStorage.GunShared.Assets
local Effects = Assets.Effects
local VFX = Effects.VFX

return function(barrel: Attachment, soundId: number)
	if GunUtil:GetVFXEnabled() and GunUtil:OnScreen(barrel.WorldPosition) then
		for _, effect in VFX.Fire:GetChildren() do
			effect = effect:Clone()

			if effect:IsA("ParticleEmitter") then
				effect:Emit(effect:GetAttribute("EmitCount") or 5)
			end

			effect.Parent = barrel
			task.delay(effect.Lifetime.Max, effect.Destroy, effect)
		end
	end

	EffectHandler.PlaySound(soundId, barrel.WorldPosition, 0.5)
end



--!strict

local FOV_TWEENINFO = TweenInfo.new(0.3)

local MOUSE_DELTA_IMPACT = 100
local ALPHA_SPEED = 10

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local Maid = require(ReplicatedStorage.GunShared.Packages.Maid)
local Types = require(ReplicatedStorage.GunShared.Types)
local Value = require(ReplicatedStorage.GunShared.Packages.Value)

local CFrameOffsets = require(script.Parent.Parent.Modules.CFrameOffsets)

local Assets = ReplicatedStorage.GunShared.Assets
local Misc = Assets.Misc

local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local ViewModelHandler = {}
ViewModelHandler.__index = ViewModelHandler

function ViewModelHandler.new(gunHandler: any)
	local self = setmetatable({}, ViewModelHandler)

	self._maid = Maid.new()
	self._fpsMaid = self._maid:Add(Maid.new())

	self._gunHandler = gunHandler
	self._gun = self._gunHandler.Gun
	self._gunConfig = self._gunHandler.Config
	self._gunMotor6D = self._gunHandler.GunMotor6D
	self._aimPart = self._gun:FindFirstChild("AimPart", true) :: BasePart?
	self._aim = self._gunHandler.Aim :: Value.Value<boolean>

	self._character = Player.Character :: Types.PlayerCharacter
	self._humanoidRootPart = self._character.HumanoidRootPart
	self._head = self._character.Head

	self.ViewModel = self._maid:Add(Misc.ViewModel:Clone() :: Types.ViewModel)
	self.ViewModel["Right Arm"].Color = self._character["Right Arm"].Color
	self.ViewModel["Left Arm"].Color = self._character["Left Arm"].Color
	self.ViewModel.Parent = Camera

	local bodyColors = self._character:FindFirstChild("Body Colors")
	if bodyColors then
		bodyColors:Clone().Parent = self.ViewModel
	end

	local shirt = self._character:FindFirstChild("Shirt")
	if shirt then
		shirt:Clone().Parent = self.ViewModel
	end

	self._cframeOffsets = CFrameOffsets.new()
	self._lastPart0 = nil :: BasePart?

	self.Enabled = self._maid:Add(Value.new(false))

	self.Enabled:Observe(function(value: boolean)
		self:_stop()

		if value == true then
			self:_start()
		end
	end)

	return self
end

function ViewModelHandler:_start()
	self._lastPart0 = self._gunMotor6D.Part0
	self:_getPartsFromViewModel(function(part: BasePart)
		if part.Name == "Left Arm" or part.Name == "Right Arm" then
			part.Anchored = false
		end
		part.CanCollide = false
		part.CanQuery = false
		part.CanTouch = false
	end)

	local function onUpdate(deltaTime: number)
		local inputDelta = UserInputService:GetMouseDelta()
		local moveOffset = Vector3.new(
			math.clamp((inputDelta.X / 5) * deltaTime, -MOUSE_DELTA_IMPACT, MOUSE_DELTA_IMPACT),
			math.clamp((inputDelta.Y / 5) * deltaTime, -MOUSE_DELTA_IMPACT, MOUSE_DELTA_IMPACT),
			0
		)

		self._cframeOffsets:Lerp("MouseMove", CFrame.new(moveOffset.X, moveOffset.Y, 0), ALPHA_SPEED * deltaTime)
		if self._aimPart and self._gunConfig.Aim then
			self._cframeOffsets:Lerp(
				"Aim",
				if self._aim.Value == true
					then self._aimPart.CFrame:ToObjectSpace(self.ViewModel.Head.CFrame)
					else CFrame.new(),
				ALPHA_SPEED * deltaTime
			)
		end

		self.ViewModel:PivotTo(Camera.CFrame * self._cframeOffsets:Get())
		self._gunMotor6D.C0 = CFrame.new(0, -1, 0) * self._gunConfig.HandleOffset
	end
	self.ViewModel:PivotTo(Camera.CFrame)

	self._fpsMaid:GiveTask(RunService.RenderStepped:Connect(onUpdate))
	self._fpsMaid:GiveTask(self._aim:Observe(function(aimEnabled: boolean)
		if not self._gunConfig.Aim then
			return
		end

		if aimEnabled == true then
			TweenService:Create(Camera, FOV_TWEENINFO, { FieldOfView = self._gunConfig.Aim.FOV }):Play()
		else
			TweenService:Create(Camera, FOV_TWEENINFO, { FieldOfView = 70 }):Play()
		end
	end))

	self._gunMotor6D.Part0 = self.ViewModel["Right Arm"]

	self:_setLocalTransparency(0)
end

function ViewModelHandler:_stop()
	self._gunMotor6D.Part0 = self._lastPart0 or self._character["Right Arm"]
	self._gunMotor6D.C0 = self._gunConfig.HandleOffset

	self.ViewModel:PivotTo(CFrame.new(0, 9e9, 0))
	self:_setLocalTransparency(1)
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default

	TweenService:Create(Camera, FOV_TWEENINFO, { FieldOfView = 70 }):Play()

	self._fpsMaid:DoCleaning()
end

function ViewModelHandler:_getPartsFromViewModel(fn: (BasePart) -> ())
	for _, part in self.ViewModel:GetDescendants() do
		if not part:IsA("BasePart") then
			continue
		end

		fn(part)
	end
end

function ViewModelHandler:_setLocalTransparency(value: number)
	self:_getPartsFromViewModel(function(part: BasePart)
		part.LocalTransparencyModifier = value
		part.CanCollide = false
		part.CanQuery = false
		part.CanTouch = false
	end)
end

function ViewModelHandler:Destroy()
	self._maid:DoCleaning()
	self:_stop()
	table.clear(self)
	setmetatable(self, nil)
end

return ViewModelHandler



local HITMARK_TWEENINFO = TweenInfo.new(1.5, Enum.EasingStyle.Quint)

local Debris = game:GetService("Debris")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Maid = require(ReplicatedStorage.GunShared.Packages.Maid)

local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local PlayerGui = Player:WaitForChild("PlayerGui")

local Assets = ReplicatedStorage.GunShared.Assets
local Interfaces = Assets.Interfaces
local Misc = Assets.Misc

local GuiHandler = {}
GuiHandler.__index = GuiHandler

function GuiHandler.new(gunHandler: any)
	local self = setmetatable({}, GuiHandler)

	self._maid = Maid.new()

	self._gunHandler = gunHandler
	self._gun = self._gunHandler.Gun
	self._gunConfig = self._gunHandler.Config

	self._gui = self._maid:Add(Misc.GunGui:Clone())
	self._gui.Parent = PlayerGui

	self._gui.Info.GunName.Text = self._gun.Name

	return self
end

function GuiHandler:UpdateBullet()
	local currentBulletAmount = self._gunHandler:GetBulletAmount()
	local bulletCapacity = self._gunConfig.Ammo

	self._gui.Info.BulletAmount.Text = `{currentBulletAmount}/{bulletCapacity}`
end

function GuiHandler:UpdateFiremode()
	local firemode = self._gunHandler:GetFiremode()
	self._gui.Firemode.Text = firemode
end

function GuiHandler:UpdateCrosshairVisible()
	local crosshair = self._gui.Crosshair
	local cameraType = self._gunHandler.CameraType.Value
	local aimState = self._gunHandler.Aim.Value

	crosshair.Visible = if cameraType == "FPS" then not aimState else aimState
end

function GuiHandler:SetReloadBarProgress(value: number)
	local reloadFrame = self._gui.ReloadProgress
	reloadFrame.Bar.Size = UDim2.new(value, 0, 1, 0)
end

function GuiHandler:SetReloadBarVisible(value: number)
	local reloadFrame = self._gui.ReloadProgress
	reloadFrame.Visible = value
end

function GuiHandler:CreateHitmark(hitPosition: Vector3)
	local screenPoint = Camera:WorldToScreenPoint(hitPosition)
	local guiInset = GuiService:GetGuiInset()

	local hitmark = Interfaces.Hitmark:Clone()
	hitmark.Name = "____________________"
	hitmark.Visible = true
	hitmark.ImageColor3 = Color3.fromRGB(255, 255, 255)
	hitmark.Position = UDim2.new(0, screenPoint.X, 0, screenPoint.Y + guiInset.Y)
	hitmark.Parent = self._gui

	TweenService:Create(hitmark, HITMARK_TWEENINFO, { ImageTransparency = 1, Size = UDim2.new() }):Play()
	Debris:AddItem(hitmark, HITMARK_TWEENINFO.Time)
end

function GuiHandler:Destroy()
	self._maid:DoCleaning()
	table.clear(self)
	setmetatable(self, nil)
end

return GuiHandler



local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Types = require(ReplicatedStorage.GunShared.Types)

local Effects = script.Parent.Parent.Modules.Effects

return setmetatable({} :: Types.Effects, {
	__index = function(self, index)
		local effectModule = Effects:FindFirstChild(index)

		if effectModule then
			local fn = require(effectModule)
			rawset(self, index, fn)
			return fn
		end

		return nil
	end,
})


--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Maid = require(ReplicatedStorage.GunShared.Packages.Maid)
local Types = require(ReplicatedStorage.GunShared.Types)

local AnimationTrackHandler = {}
AnimationTrackHandler.__index = AnimationTrackHandler

function AnimationTrackHandler.new(
	character: Types.PlayerCharacter,
	viewModel: Types.ViewModel,
	animations: { [string]: Animation }
)
	local self = setmetatable({}, AnimationTrackHandler)

	self._maid = Maid.new()

	self._character = character
	self._viewModel = viewModel

	self._animators = {
		self._character.Humanoid.Animator,
		self._viewModel.Humanoid.Animator,
	}
	self._loadedAnimations = {} :: { [string]: { AnimationTrack } }

	for _, animation in animations do
		if typeof(animation) ~= "Instance" or not animation:IsA("Animation") then
			continue
		end

		if typeof(self._loadedAnimations[animation.Name]) ~= "table" then
			self._loadedAnimations[animation.Name] = {}
		end

		self:_listAnimators(function(animator)
			local animationTrack = self._maid:Add(animator:LoadAnimation(animation))
			table.insert(self._loadedAnimations[animation.Name], animationTrack)
		end)
	end

	return self
end

function AnimationTrackHandler:Play(name: string, fadeTime: number?, weight: number?, speed: number?)
	self:_listAnimationTracks(name, function(animationTrack: AnimationTrack)
		animationTrack:Play(fadeTime, weight, speed)
	end)
end

function AnimationTrackHandler:Stop(name: string, fadeTime: number?)
	self:_listAnimationTracks(name, function(animationTrack: AnimationTrack)
		animationTrack:Stop(fadeTime)
	end)
end

function AnimationTrackHandler:Get(name: string): AnimationTrack?
	return if self._loadedAnimations[name] then self._loadedAnimations[name][1] else nil
end

function AnimationTrackHandler:_listAnimators(fn: (Animator) -> ())
	for _, animator in self._animators do
		if typeof(animator) ~= "Instance" or not animator:IsA("Animator") then
			continue
		end

		fn(animator)
	end
end

function AnimationTrackHandler:_listAnimationTracks(name: string, fn: (AnimationTrack) -> ())
	for _, animationTrack in self._loadedAnimations[name] do
		if typeof(animationTrack) ~= "Instance" or not animationTrack:IsA("AnimationTrack") then
			continue
		end

		fn(animationTrack)
	end
end

function AnimationTrackHandler:Destroy()
	self._maid:DoCleaning()
	table.clear(self)
	setmetatable(self, nil)
end

return AnimationTrackHandler


--!strict
--!native

local BODY_TWEEN_INFO = TweenInfo.new(0.25)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterPlayer = game:GetService("StarterPlayer")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local Config = require(ReplicatedStorage.GunShared.Config)
local Bridges = require(ReplicatedStorage.GunShared.Modules.Bridges)
local Maid = require(ReplicatedStorage.GunShared.Packages.Maid)
local Value = require(ReplicatedStorage.GunShared.Packages.Value)
local GunUtil = require(ReplicatedStorage.GunShared.Modules.GunUtil)
local Raycast = require(ReplicatedStorage.GunShared.Modules.Raycast)
local Types = require(ReplicatedStorage.GunShared.Types)

local ViewModelHandler = require(script.Parent.ViewModelHandler)
local AnimationTrackHandler = require(script.Parent.AnimationTrackHandler)
local EffectHandler = require(script.Parent.EffectHandler)
local GuiHandler = require(script.Parent.GuiHandler)

local ContextAction = require(script.Parent.Parent.Modules.ContextAction)
local CameraLock = require(script.Parent.Parent.Modules.CameraLock)

local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local GunActor = script.Parent.Parent.Parent
local RF = ReplicatedStorage.GunShared.RF

local GunHandler = {}
GunHandler.__index = GunHandler

function GunHandler.new(gun: Tool, crouchEnabled: Value.Value<boolean>)
	local self = setmetatable({}, GunHandler)

	self._maid = Maid.new()

	self.Gun = gun
	self._handle = self.Gun:FindFirstChild("Handle", true)
	assert(self._handle, "Bad Handle")
	self._barrel = self._handle:FindFirstChild("Barrel")
	assert(self._barrel, "Bad Barrel")
	self._shell = self._handle:FindFirstChild("Shell")
	assert(self._shell, "Bad Shell")
	self.Config = GunUtil:GetConfig(self.Gun)

	self.Config.HandleOffset = self.Config.HandleOffset or CFrame.new()

	self._crouch = crouchEnabled

	self._character = Player.Character
	self._humanoid = self._character.Humanoid
	self._humanoidRootPart = self._character:FindFirstChild("HumanoidRootPart")

	self.GunMotor6D = self._humanoidRootPart:FindFirstChild("GunMotor6D") :: Motor6D
	assert(self.GunMotor6D, "Bad GunMotor6D")

	self.CameraType = self._maid:Add(Value.new("TPS")) :: Value.Value<Types.CameraTypes>
	self.Aim = self._maid:Add(Value.new(false)) :: Value.Value<boolean>

	self._viewModelHandler = self._maid:Add(ViewModelHandler.new(self))
	self._guiHandler = self._maid:Add(GuiHandler.new(self))
	self._animationTrackHandler = self._maid:Add(
		AnimationTrackHandler.new(self._character, self._viewModelHandler.ViewModel, GunUtil:GetAnimations(self.Gun))
	)

	self._ignoreInstances = { self._character, self.Gun, self._viewModelHandler.ViewModel, workspace.GUN_GARBAGE }

	self:_equip()

	return self
end

function GunHandler:_equip()
	self._activeFire = nil :: (() -> ())?
	self._activeTPSAim = nil :: (() -> ())?
	self._lastClick = tick()
	self._reloadActive = false
	self._altReloadActive = false
	self._cameraLockManager = self._maid:Add(CameraLock.new(self._ignoreInstances))

	self.GunMotor6D.Part1 = self._handle
	self.GunMotor6D.C0 = self.Config.HandleOffset

	self:_listenToHeadLocalTransparency()
	self:_buildActions()

	self._c0List = {
		Neck = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
		RightShoulder = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
		LeftShoulder = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	}

	self.CameraType:Observe(function(cameraType: Types.CameraTypes)
		if cameraType == "FPS" then
			self._viewModelHandler.Enabled.Value = true
			self._animationTrackHandler:Stop("safe")
		elseif cameraType == "TPS" then
			self._viewModelHandler.Enabled.Value = false

			if not self.Aim.Value and not self._reloadActive then
				self._animationTrackHandler:Play("safe")
			end
		end

		self._guiHandler:UpdateCrosshairVisible()
	end)

	self.Aim:Observe(function(aimEnabled: boolean)
		if aimEnabled == true then
			if self.CameraType.Value == "TPS" then
				self._animationTrackHandler:Stop("safe", 0.2)
			end

			self:_clearTPSAim()
			self._activeTPSAim = self:_startTPSAim()
		else
			self:_clearTPSAim()

			if self.CameraType.Value == "TPS" then
				self._animationTrackHandler:Play("safe")
			end
		end

		if ContextAction:IsMobile() then
			ContextAction:SetTouchDeltaSensitivity(if aimEnabled == true then Config.AimSensitivitys.Mobile else 1)
		else
			UserInputService.MouseDeltaSensitivity = if aimEnabled == true then Config.AimSensitivitys.Computer else 1
		end

		self._guiHandler:UpdateCrosshairVisible()
	end)

	local function onChangedBulletAmount()
		self._guiHandler:UpdateBullet()
	end

	local function onChangedFiremode()
		self._guiHandler:UpdateFiremode()
	end

	self._maid:GiveTask(
		self.Gun:GetAttributeChangedSignal(Config.BulletAmountAttributeName):Connect(onChangedBulletAmount)
	)
	onChangedBulletAmount()
	self._maid:GiveTask(self.Gun:GetAttributeChangedSignal(Config.FiremodeAttributeName):Connect(onChangedFiremode))
	onChangedFiremode()

	self._maid:GiveTask(RunService.RenderStepped:Connect(function()
		UserInputService.MouseIconEnabled = false
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	end))
	if ContextAction:IsMobile() then
		self:_setMobileCameraType("TPS")
	end

	-- Function running when maid cleans
	self._maid:GiveTask(function()
		UserInputService.MouseIconEnabled = true
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseDeltaSensitivity = 1
		ContextAction:SetTouchDeltaSensitivity(1)

		Player.CameraMode = Enum.CameraMode.Classic
		Player.CameraMinZoomDistance = StarterPlayer.CameraMinZoomDistance
		Player.CameraMaxZoomDistance = StarterPlayer.CameraMaxZoomDistance
	end)

	self._animationTrackHandler:Play("idle")
	if self.CameraType.Value ~= "FPS" then
		self._animationTrackHandler:Play("safe")
	end
end

function GunHandler:_buildActions()
	-- Fire
	self._maid:GiveTask(ContextAction.new(function(state: Enum.UserInputState)
		if state == Enum.UserInputState.Begin then
			self._activeFire = self:_startFire()

			return Enum.ContextActionResult.Sink
		elseif state == Enum.UserInputState.End or state == Enum.UserInputState.Cancel then
			self:_clearFire()
		end

		return Enum.ContextActionResult.Pass
	end, Config.InputKeys.Fire):CreateButton({
		Image = "rbxassetid://15468653194",
		Position = UDim2.fromScale(-1.3, 0),
		Size = UDim2.fromScale(1.3, 1.3),
		Active = false,
		TouchingFarAway = true,
	}))

	-- Aim
	self._maid:GiveTask(ContextAction.new(function(state: Enum.UserInputState)
		if state ~= Enum.UserInputState.Cancel and state ~= Enum.UserInputState.None then
			if self._reloadActive then
				return
			end
		end

		if Config.HoldOnAim == true then
			if ContextAction:IsMobile() then
				if state == Enum.UserInputState.Begin then
					self.Aim.Value = not self.Aim.Value

					return Enum.ContextActionResult.Sink
				end
			else
				if state == Enum.UserInputState.Begin then
					self.Aim.Value = true

					return Enum.ContextActionResult.Sink
				elseif state == Enum.UserInputState.End then
					self.Aim.Value = false
				end
			end
		else
			if state == Enum.UserInputState.Begin then
				self.Aim.Value = not self.Aim.Value

				return Enum.ContextActionResult.Sink
			end
		end

		return Enum.ContextActionResult.Pass
	end, Config.InputKeys.Aim):CreateButton({
		Image = "rbxassetid://13312613977",
		Position = UDim2.fromScale(-0.2, -1.45),
		TouchingFarAway = false,
	}))

	-- Reload
	self._maid:GiveTask(ContextAction.new(function(state: Enum.UserInputState)
		if state == Enum.UserInputState.Begin then
			self:_reload()

			return Enum.ContextActionResult.Sink
		end

		return Enum.ContextActionResult.Pass
	end, Config.InputKeys.Reload):CreateButton({
		Image = "rbxassetid://15468661354",
		Position = UDim2.fromScale(0.7, -1.45),
		TouchingFarAway = false,
	}))

	-- Firemode
	if self.Config.Fire.Mode.Change == true then
		self._maid:GiveTask(ContextAction.new(function(state: Enum.UserInputState)
			if state == Enum.UserInputState.Begin then
				self:_changeFiremode()

				return Enum.ContextActionResult.Sink
			end

			return Enum.ContextActionResult.Pass
		end, Config.InputKeys.Firemode):CreateButton({
			Title = "Firemode",
			Position = UDim2.fromScale(0.7, -2.3),
			TouchingFarAway = false,
		}))
	end

	-- Camera Mode
	if ContextAction:IsMobile() then
		self._maid:GiveTask(ContextAction.new(function(state: Enum.UserInputState)
			if state == Enum.UserInputState.Begin then
				self:_changeMobileCameraType()

				return Enum.ContextActionResult.Sink
			end

			return Enum.ContextActionResult.Pass
		end, Enum.KeyCode.Unknown):CreateButton({
			Title = "Camera",
			Position = UDim2.fromScale(-1.2, -1.2),
			TouchingFarAway = false,
		}))
	end
end

function GunHandler:_fire()
	if self.CameraType.Value == "TPS" and not self.Aim.Value then
		self:_clearFire()
		return
	end

	if self._reloadActive or not self:_checkFire() then
		if Config.AutoReload == true then
			self:_reload()
		else
			self:_clearFire()
		end

		return
	end

	local spread = self.Config.Fire.Spread * 100
	local sounds = self.Config.Sounds
	local bullet = self.Config.Bullet
	local bulletCount = bullet.Count or 1

	local altReloadAnimationTrack: AnimationTrack = self._animationTrackHandler:Get("altReload")
	if self._altReloadActive == true and altReloadAnimationTrack then
		self._animationTrackHandler:Play("altReload")
		self._altReloadActive = false

		EffectHandler.PlaySound(sounds.AltReload)
		EffectHandler.CreateShell(
			bullet.Type,
			self._shell.WorldCFrame,
			self._humanoidRootPart.CFrame.RightVector * math.random(unpack(bullet.Range))
				+ Vector3.new(0, math.random(unpack(bullet.Up)), 0)
		)

		return
	end

	local origin: Vector3 = self._barrel.WorldPosition
	local playerCrouch = 1
	if bulletCount <= 1 then
		playerCrouch = self._crouch.Value == true and 0.4 or 1
	end
	local bulletList = {}

	for _ = 1, bulletCount do
		local target: Vector3 = Raycast:GetScreenFromWorldPosition(Camera.ViewportSize / 2, self._ignoreInstances)
		local recoil = Vector3.new(
			Random.new():NextNumber(-spread, spread),
			Random.new():NextNumber(-spread, spread),
			Random.new():NextNumber(-spread, spread)
		) * 0.01 * playerCrouch * (target - origin).Magnitude

		local wallRaycastResult: RaycastResult? =
			Raycast:GetWallHit(origin, target, self._humanoidRootPart.Position, self._ignoreInstances)

		target += recoil
		local direction: Vector3 = (target - origin).Unit

		local function onRayHit(raycastResult: RaycastResult)
			local hitResult: Types.HitResult? = RF.Hit:InvokeServer({
				Instance = raycastResult.Instance,
			})

			if hitResult then
				local totalDamage = hitResult.TotalDamage
				local hitPosition = raycastResult.Position

				if self._guiHandler and self._guiHandler.CreateHitmark then
					self._guiHandler:CreateHitmark(hitPosition, totalDamage)
				end
			end
		end

		table.insert(bulletList, target)
		GunActor:SendMessage("ActorGunFire", {
			Origin = origin,
			Direction = direction,
			GunTool = self.Gun,
			Character = self._character,
			IgnoreInstances = self._ignoreInstances,
			WallRaycastResult = wallRaycastResult,
			OnRayHit = onRayHit,
		})
	end

	Bridges.Fire:Fire({ BulletList = bulletList })
	self:_setBulletAmount(self:GetBulletAmount() - 1)
	if not altReloadAnimationTrack then
		EffectHandler.CreateShell(
			bullet.Type,
			self._shell.WorldCFrame,
			self._humanoidRootPart.CFrame.RightVector * math.random(unpack(bullet.Range))
				+ Vector3.new(0, math.random(unpack(bullet.Up)), 0)
		)
	end
	self._animationTrackHandler:Play(
		"fire",
		nil,
		if self.Aim.Value == true and self.CameraType.Value == "FPS" then self.Config.Fire.AimWeight else nil
	)

	self._altReloadActive = true
end

function GunHandler:_reload()
	local bulletCapacity: number = self.Config.Ammo
	local bulletAmount: number = self:GetBulletAmount()

	if self._reloadActive or bulletAmount == bulletCapacity then
		return
	end

	local sounds = self.Config.Sounds
	local reloadAnimationTrack: AnimationTrack? = self._animationTrackHandler:Get("reload")
	local preReloadAnimationTrack: AnimationTrack? = self._animationTrackHandler:Get("preReload")

	if reloadAnimationTrack then
		self._maid:GiveTask(task.spawn(function()
			self._guiHandler:SetReloadBarProgress(0)
			self._guiHandler:SetReloadBarVisible(true)

			repeat
				task.wait()

				local progress = reloadAnimationTrack.TimePosition / reloadAnimationTrack.Length
				self._guiHandler:SetReloadBarProgress(progress)
			until progress == 1 or not reloadAnimationTrack.IsPlaying

			if self.CameraType.Value == "TPS" then
				self._animationTrackHandler:Play("safe")
			end
			self._reloadActive = false

			task.wait(0.3)
			self._guiHandler:SetReloadBarVisible(false)
		end))

		self._animationTrackHandler:Play("reload")
		local reachedSignalConnection
		reachedSignalConnection = reloadAnimationTrack:GetMarkerReachedSignal("Loaded"):Connect(function()
			self:_setBulletAmount(bulletCapacity)
			Bridges.Reload:Fire()
			reachedSignalConnection:Disconnect()
		end)
	elseif preReloadAnimationTrack then
		local insertBulletAnimationTrack: AnimationTrack = self._animationTrackHandler:Get("insertBullet")
		local altReloadAnimationTrack: AnimationTrack = self._animationTrackHandler:Get("altReload")

		self._maid:GiveTask(task.spawn(function()
			self._animationTrackHandler:Play("preReload")
			task.wait(preReloadAnimationTrack.Length)

			self._guiHandler:SetReloadBarVisible(true)
			for _ = 1, (bulletCapacity - bulletAmount) do
				self._animationTrackHandler:Play("insertBullet")
				EffectHandler.PlaySound(sounds.InsertBullet)

				self._guiHandler:SetReloadBarProgress(0)
				repeat
					task.wait()

					local progress = insertBulletAnimationTrack.TimePosition / insertBulletAnimationTrack.Length
					self._guiHandler:SetReloadBarProgress(progress)
				until progress == 1 or not insertBulletAnimationTrack.IsPlaying

				self:_setBulletAmount(math.clamp(self:GetBulletAmount() + 1, 1, bulletCapacity))
				Bridges.Reload:Fire("Shotgun")
			end

			self._animationTrackHandler:Play("altReload")
			EffectHandler.PlaySound(sounds.AltReload)
			task.delay(altReloadAnimationTrack.Length, function()
				if self.CameraType and self.CameraType.Value == "TPS" then
					self._animationTrackHandler:Play("safe")
				end
			end)

			self._reloadActive = false
			self._altReloadActive = false

			task.wait(0.3)
			self._guiHandler:SetReloadBarVisible(false)
		end))
	end

	self._reloadActive = true
	self.Aim.Value = false

	if sounds.Reload then
		local reloadSound = EffectHandler.PlaySound(sounds.Reload)
		if reloadSound then
			self._maid:GiveTask(reloadSound)
		end
	end

	self._animationTrackHandler:Stop("safe")
	self._animationTrackHandler:Stop("fire")
	self:_clearFire()
end

function GunHandler:_startFire()
	self:_clearFire()

	local firemode = self:GetFiremode()
	local fireRate = self.Config.Fire.Rate

	if (tick() - self._lastClick) < fireRate then
		return
	end
	self._lastClick = tick()

	if firemode == "Auto" then
		self._autoModeThread = self._maid:Add(task.spawn(function()
			while true do
				self:_fire()
				task.wait(fireRate)
			end
		end))
	elseif firemode == "Single" then
		self:_fire()
	end
end

function GunHandler:_clearFire()
	if self._autoModeThread then
		local success
		if coroutine.running() ~= self._autoModeThread then
			success = pcall(task.cancel, self._autoModeThread)
		end

		if not success then
			task.defer(function()
				if self._autoModeThread then
					task.cancel(self._autoModeThread)
				end
			end)
		end
	end
end

function GunHandler:_startTPSAim(): () -> ()
	local torso = self._character.Torso
	local neck: Motor6D = torso.Neck
	local rightShoulder: Motor6D = torso["Right Shoulder"]
	local leftShoulder: Motor6D = torso["Left Shoulder"]

	self._cameraLockManager.Enabled.Value = true

	local function updateBody(deltaTime: number)
		local origin = Camera.CFrame.Position
		local target = Raycast:GetScreenFromWorldPosition(Camera.ViewportSize / 2, self._ignoreInstances, true)

		local direction = (origin - target).Unit
		local rx = -math.asin(direction.Y)

		neck.C0 = neck.C0:Lerp(
			CFrame.new(self._c0List.Neck.Position) * CFrame.Angles(rx + math.pi / 2, math.pi, 0),
			10 * deltaTime
		)
		rightShoulder.C0 = rightShoulder.C0:Lerp(
			CFrame.new(self._c0List.RightShoulder.Position) * CFrame.Angles(rx, math.pi / 2, 0),
			10 * deltaTime
		)
		leftShoulder.C0 = leftShoulder.C0:Lerp(
			CFrame.new(self._c0List.LeftShoulder.Position) * CFrame.Angles(rx, -math.pi / 2, 0),
			10 * deltaTime
		)
	end

	local steppedConnection = RunService.RenderStepped:ConnectParallel(updateBody)

	-- Cleaner function
	return self._maid:Add(function()
		if self._humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
			TweenService:Create(neck, BODY_TWEEN_INFO, { C0 = self._c0List.Neck }):Play()
			TweenService:Create(rightShoulder, BODY_TWEEN_INFO, { C0 = self._c0List.RightShoulder }):Play()
			TweenService:Create(leftShoulder, BODY_TWEEN_INFO, { C0 = self._c0List.LeftShoulder }):Play()
		end

		if steppedConnection and steppedConnection.Connected then
			steppedConnection:Disconnect()
		end
		if self._cameraLockManager and self._cameraLockManager.Enabled then
			self._cameraLockManager.Enabled.Value = false
		end
	end)
end

function GunHandler:_clearTPSAim()
	if self._activeTPSAim then
		self._activeTPSAim()
		self._activeTPSAim = nil
	end
end

function GunHandler:_checkFire(): boolean
	return self:GetBulletAmount() > 0
end

function GunHandler:GetBulletAmount(): number
	return self.Gun:GetAttribute(Config.BulletAmountAttributeName)
		or if Config.DebugMode then math.huge else self.Config.Ammo
end

function GunHandler:GetFiremode(): Types.Firemodes
	return self.Gun:GetAttribute(Config.FiremodeAttributeName) or self.Config.Fire.Mode.Value
end

function GunHandler:_changeFiremode()
	self:_clearFire()

	local firemode = self:GetFiremode()
	local newFiremode = if firemode == "Auto" then "Single" else "Auto"

	self.Gun:SetAttribute(Config.FiremodeAttributeName, newFiremode)
end

function GunHandler:_setMobileCameraType(mode: Types.CameraTypes)
	if mode == "FPS" then
		Player.CameraMode = Enum.CameraMode.LockFirstPerson
		Player.CameraMinZoomDistance = StarterPlayer.CameraMinZoomDistance
		Player.CameraMaxZoomDistance = StarterPlayer.CameraMaxZoomDistance
	elseif mode == "TPS" then
		Player.CameraMode = Enum.CameraMode.Classic
		Player.CameraMinZoomDistance = 10
		Player.CameraMaxZoomDistance = 10
	end
end

function GunHandler:_changeMobileCameraType()
	self:_setMobileCameraType(if Player.CameraMode == Enum.CameraMode.LockFirstPerson then "TPS" else "FPS")
end

function GunHandler:_setBulletAmount(value: number)
	self.Gun:SetAttribute(Config.BulletAmountAttributeName, value)
end

function GunHandler:_listenToHeadLocalTransparency()
	local head = self._character.Head

	local function _onChanged()
		local newType = "TPS"
		if head.LocalTransparencyModifier >= 1 then
			newType = "FPS"
		end

		if self.CameraType.Value ~= newType then
			self.CameraType.Value = newType
		end
	end

	self._maid:GiveTask(head:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(_onChanged))
	_onChanged()
end

function GunHandler:Destroy()
	self._maid:DoCleaning()
	table.clear(self)
	setmetatable(self, nil)
end

return GunHandler




local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")

local Player = Players.LocalPlayer

local Config = require(ReplicatedStorage.GunShared.Config)
local Bridges = require(ReplicatedStorage.GunShared.Modules.Bridges)
local GunUtil = require(ReplicatedStorage.GunShared.Modules.GunUtil)
local Types = require(ReplicatedStorage.GunShared.Types)

local GunHandler = require(script.Handlers.GunHandler)
local EffectHandler = require(script.Handlers.EffectHandler)
local ContextAction = require(script.Modules.ContextAction)

local Crouch = require(script.Modules.Crouch)

local GunActor = script.Parent

local GunGarbage = Instance.new("Folder")
GunGarbage.Name = "GUN_GARBAGE"
GunGarbage.Parent = workspace

local CrouchManager = Crouch.new()
local CrouchAnimation = Instance.new("Animation")
CrouchAnimation.Name = "Crouch"
CrouchAnimation.AnimationId = Config.CrouchAnimationId
CrouchAnimation.Parent = ReplicatedStorage.GunShared.Assets

local ActiveGunHandler
local function onUnequipped()
	if ActiveGunHandler then
		ActiveGunHandler:Destroy()
		ActiveGunHandler = nil
	end
end


local function onCharacterAdded(character: Model)
	local humanoid = character:WaitForChild("Humanoid", 9e9)
	character:WaitForChild("HumanoidRootPart", 9e9)


	GunUtil:ListenToCharacter(character, function(gunTool: Tool)
		onUnequipped()
		if humanoid:GetState() == Enum.HumanoidStateType.Dead then
			return
		end

		ActiveGunHandler = GunHandler.new(gunTool, CrouchManager.Enabled)

	end, onUnequipped)

	humanoid.Died:Connect(onUnequipped)

	CrouchManager:LoadAnimation(CrouchAnimation)
end

local function onGunFire(content: Types.ReplicaBulletResult)
	local gunTool = content.GunTool

	if not content.Character or not content.Character:FindFirstChild("HumanoidRootPart") then
		return
	end

	local handle = gunTool:FindFirstChild("Handle", true)
	if not handle then
		return
	end
	local barrel: Attachment = handle.Barrel

	if not table.find(content.IgnoreInstances, GunGarbage) then
		table.insert(content.IgnoreInstances, GunGarbage)
	end

	task.synchronize()
	if content.WallRaycastResult then
		EffectHandler.MaterialHit(content.WallRaycastResult)

		if content.OnRayHit then
			task.spawn(content.OnRayHit, content.WallRaycastResult)
		end
	else
		local caster = EffectHandler.CreateBullet(content.Origin, content.Direction, content.IgnoreInstances)
		if content.OnRayHit then
			caster.RayHit:Connect(function(raycastResult: RaycastResult)
				task.spawn(content.OnRayHit, raycastResult)
			end)
		end
	end

	local config = GunUtil:GetConfig(gunTool)
	local sounds = config.Sounds

	EffectHandler.BarrelFire(barrel, sounds.Fire)
end

GunActor:BindToMessageParallel("ActorGunFire", onGunFire)


Player.CharacterAdded:Connect(onCharacterAdded)
if Player.Character then
	onCharacterAdded(Player.Character)
end
Player.CharacterRemoving:Connect(onUnequipped)

Bridges.CreateBullet:Connect(function(content)
	GunActor:SendMessage("ActorGunFire", content)
end)

ContextAction.new(function(state: Enum.UserInputState, inputObject: InputObject?)
	if inputObject and inputObject.KeyCode == Config.InputKeys.Crouch[2] then
		if state == Enum.UserInputState.Begin then
			CrouchManager.Enabled.Value = true

			return Enum.ContextActionResult.Sink
		else
			CrouchManager.Enabled.Value = false
		end
	else
		if state == Enum.UserInputState.Begin then
			CrouchManager.Enabled.Value = not CrouchManager.Enabled.Value

			return Enum.ContextActionResult.Sink
		end
	end

	return Enum.ContextActionResult.Pass
end, unpack(Config.InputKeys.Crouch)):CreateButton({
	Image = "rbxassetid://15468664369",
	Position = UDim2.fromScale(0.7, -0.6),
	TouchingFarAway = false,
})




Player:SetAttribute("BTFGun_RunWhenHoldingShift", false)


local mobile = UIS.TouchEnabled

local running = false

local function SetRunning(IsRunning)
	if not Player.Character then return end

	running = IsRunning

	if running then
		Player.Character.Humanoid.WalkSpeed = 28
	else
		Player.Character.Humanoid.WalkSpeed = 16
	end
end


local function HandleRun(state)

	if mobile then
		if state == Enum.UserInputState.End then
			SetRunning(not running)
		end

	else
		if Player:GetAttribute("BTFGun_RunWhenHoldingShift") then
			if state == Enum.UserInputState.Begin then
				SetRunning(true)
			elseif state == Enum.UserInputState.End then
				SetRunning(false)
			end

		else
			if state == Enum.UserInputState.Begin then
				SetRunning(not running)
			end
		end
	end
end

ContextAction.new(HandleRun, Config.InputKeys.Sprint):CreateButton({
	Image = "rbxassetid://15733974909",
	Position = UDim2.fromScale(-0.2, -0.6),
	TouchingFarAway = false,
})



local TweenService = game:GetService("TweenService")

local info = TweenInfo.new(
	.5,
	Enum.EasingStyle.Sine,
	Enum.EasingDirection.InOut,
	0,
	false,
	0
)

local TextGoal0 = {
	TextTransparency = 0
}

local TextGoal1 = {
	TextTransparency = 1
}

local B = script.Parent.B
local T = script.Parent.T
local F = script.Parent.F

local team = script.Parent.team

local animB0 = TweenService:Create(B,info,TextGoal0)
local animB1 = TweenService:Create(B,info,TextGoal1)

local animT0 = TweenService:Create(T,info,TextGoal0)
local animT1 = TweenService:Create(T,info,TextGoal1)

local animF0 = TweenService:Create(F,info,TextGoal0)
local animF1 = TweenService:Create(F,info,TextGoal1)

local animteam0 = TweenService:Create(team,info,TextGoal0)
local animteam1 = TweenService:Create(team,info,TextGoal1)

animB0:Play()
B:TweenPosition(UDim2.new(0.441,0,0.461,0),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,.5)
task.wait(0.1)
animT0:Play()
T:TweenPosition(UDim2.new(0.5,0,0.461,0),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,.5)
task.wait(0.1)
animF0:Play()
F:TweenPosition(UDim2.new(0.558,0,0.461,0),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,.5)
task.wait(0.1)
animteam0:Play()
team:TweenPosition(UDim2.new(0.5,0,0.582,0),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,.5)


local it = Instance.new
local v3 = Vector3.new
local bc = BrickColor.new
local ca = CFrame.Angles
local ti = table.insert
local rn = math.random
local cf = CFrame.new

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local ts = game:GetService("TweenService")

local Config = require(ReplicatedStorage.GunShared.Config)
local Bridges = require(ReplicatedStorage.GunShared.Modules.Bridges)
local GunUtil = require(ReplicatedStorage.GunShared.Modules.GunUtil)
local Raycast = require(ReplicatedStorage.GunShared.Modules.Raycast)
local BridgeNet2 = require(ReplicatedStorage.GunShared.Packages.BridgeNet2)
local Types = require(ReplicatedStorage.GunShared.Types)

local RF = ReplicatedStorage.GunShared.RF

local GunHandler = {}
GunHandler.__index = GunHandler

local RaycastEnabled = true

local asset = "http://www.roblox.com/asset/?id="
local ids = {
	Shoot = 10209633,
	Reload = 10209636,
	Crown = 20329976,
	Crown2 = 1323306,
	Icon = 52611635,
	Explode = 2697431,
	Ring = 3270017
}


local idstrs = {}

for i, v in ids do
	local assetstr = asset .. v
	table.insert(idstrs, assetstr)
	ids[i] = assetstr
end

task.spawn(function()
	game:GetService("ContentProvider"):PreloadAsync(idstrs)
end)

function GunHandler.new(checkpart)
	if not RaycastEnabled then error("Raycasts aren't enabled!") return end

	local self = setmetatable({}, GunHandler)

	self._motor6D = {} :: { [Types.PlayerCharacter]: Motor6D }
	self._guns = {} :: { [Player]: Tool }
	self._fireCount = {} :: { [Player]: { [Tool]: number } }

	Bridges.Reload:RateLimit(2, function(player: Player)
		player:Kick()
	end)

	self:Init()

	return self
end



function GunHandler:Init()
	--[[
	Players.PlayerAdded:Connect(function(player: Player)
		self._fireCount[player] = {}

		player.CharacterAdded:Connect(function(character)
			self:_createMotor6D(character)

			GunUtil:ListenToCharacter(character, function(...)
				self:_onEquipped(player, ...)
			end, function(...)
				self:_onUnequipped(player, ...)
			end)
		end)
	end)
	]]
	local function CharAdded(player, character)
		self:_createMotor6D(character)

		GunUtil:ListenToCharacter(character, function(...)
			self:_onEquipped(player, ...)
		end, function(...)
			self:_onUnequipped(player, ...)
		end)
	end

	local function PlayerAdded(player: Player)
		self._fireCount[player] = {}

		player.CharacterAdded:Connect(function(char) CharAdded(player, char) end)
	end

	Players.PlayerAdded:Connect(PlayerAdded)
	for _,plr in game.Players:GetPlayers() do
		PlayerAdded(plr)
		if plr.Character then
			CharAdded(plr, plr.Character)
		end
	end

	Players.PlayerRemoving:Connect(function(player: Player)
		self._fireCount[player] = nil
	end)

	-- Hit
	RF.Hit.OnServerInvoke = function(player: Player, ...: any)
		return self:_onHit(player, ...)
	end

	-- Fire
	Bridges.Fire:Connect(function(player: Player, ...: any)
		self:_onFire(player, ...)
	end)

	-- Reload
	Bridges.Reload:Connect(function(player: Player)
		self:_onReload(player)
	end)
end


function GunHandler:_onEquipped(player: Player, gunTool: Tool)
	local character = player.Character
	local grip = gunTool:FindFirstChild("Handle", true)

	local gunConfig = GunUtil:GetConfig(gunTool)

	if not self._motor6D[character] then
		self:_createMotor6D(character)
	end

	self._guns[player] = gunTool
	if not self._fireCount[player][gunTool] then
		self._fireCount[player][gunTool] = 0
	end

	if grip then
		self._motor6D[character].C0 = gunConfig.HandleOffset or CFrame.new()
		self._motor6D[character].Part1 = grip
	end
end

function GunHandler:_onUnequipped(player: Player)
	self._guns[player] = nil
end

local function raycast(start: Vector3, direction, params)
	assert(typeof(start) == "Vector3", "start must be a Vector3")
	assert(typeof(direction) == "Vector3", "direction must be a Vector3")
	assert(typeof(params) == "RaycastParams", "start must be a instance of RaycastParams")
	
	return table.pack(workspace:Raycast(start, direction, params))
end

local function ft(tablez, item)
	for i = 1, #tablez do
		if tablez[i] == item then
			return i
		end
	end
	return nil
end

local function ft2(tablez, item)
	for i = 1, #tablez do
		if tablez[i][1] == item then
			return i
		end
	end
	return nil
end

function GunHandler:_onFire(player: Player, content: { BulletList: { Vector3 } })
	local gunTool = self._guns[player]
	if not gunTool then
		return
	end

	if not self:_checkFire(player, gunTool) then
		return
	end

	local character = player.Character
	if not character then
		return
	end

	local ignoreInstances = { character, gunTool }

	local humanoidRootPart: BasePart = character:FindFirstChild("HumanoidRootPart")
	local handle = gunTool:FindFirstChild("Handle", true)
	local barrel: Attachment = handle.Barrel

	local origin: Vector3 = barrel.WorldPosition
	for _, target in content.BulletList do
		local direction: Vector3 = (target - origin).Unit

		local wallRaycastResult: RaycastResult? =
			Raycast:GetWallHit(origin, target, humanoidRootPart.Position, ignoreInstances)

		Bridges.CreateBullet:Fire(BridgeNet2.PlayersExcept({ player }), {
			Origin = origin,
			Direction = direction,
			Character = character,
			GunTool = gunTool,
			IgnoreInstances = ignoreInstances,
			WallRaycastResult = wallRaycastResult and {
				Position = wallRaycastResult.Position,
				Material = wallRaycastResult.Material,
				Instance = wallRaycastResult.Instance,
				Normal = wallRaycastResult.Normal,
			},
		})
	end

	if Config.DebugMode ~= true then
		self._fireCount[player][gunTool] += 1
	end
end


local function createTracer(parent, partName, shape, x, y, z, c, a, tr, re, bc2)
	local tracer = nil

	if shape == "Wedge" then
		local part = it("WedgePart", parent)
		part.formFactor = "Custom"
	elseif shape == "CornerWedge" then
		local part = it("CornerWedgePart", parent)
	else
		local part = it("Part", parent)
		part.Shape = shape or "Block"
		part.formFactor = "Custom"
	end

	tracer.Size = v3(x or 4, y or 2, z or 2)
	tracer.Friction = 2
	tracer.CanCollide = c or true
	tracer.Anchored = a or false
	tracer.BrickColor = bc(bc2 or "")
	tracer.Transparency = tr or 0
	tracer.Reflectance = re or 0
	tracer.BottomSurface = 0
	tracer.Name = partName or "Tracer"
	tracer.Locked = true
	tracer.TopSurface = 0
	tracer.CFrame = cf(0, 0, 0)
	tracer:BreakJoints()
	tracer.Anchored = a
	return tracer
end
local raycast:NetworkPeer<MemoryStoreQueue> = require

function GunHandler:_onReload(player: Player, type: "Shotgun"?)
	local gunTool = self._guns[player]
	if not gunTool then
		return
	end

	local fireCount = self._fireCount[player][gunTool]
	if fireCount <= 0 then
		return
	end
	if fireCount < 0 then
		self._fireCount[player][gunTool] = 0
		return
	end

	if type == "Shotgun" then
		self._fireCount[player][gunTool] -= 1
	else
		self._fireCount[player][gunTool] = 0
	end
end

--[[
Unused
local function getClass(parent, className)
	for _, v in pairs(parent:GetChildren()) do
		if v:IsA(className) then
			return v
		end
	end
end

local function removeObjectIfExists(parent, objectName)
	if parent:FindFirstChild(objectName) then
		parent[objectName]:Destroy()
	end
end
]]
local network = raycast

function GunHandler:_onHit(player: Player, content: { Instance: Instance, Target: Vector3 }): Types.HitResult?
	local gunTool = self._guns[player]
	if not gunTool then
		return
	end
	local config = GunUtil:GetConfig(gunTool)

	if self:_checkFire(player, gunTool) == false then
		return
	end

	local instance = content.Instance
	if not instance:IsA("BasePart") then
		return
	end
	local hitCharacter = instance:FindFirstAncestorOfClass("Model")

	if hitCharacter then
		local hitPlayer = Players:GetPlayerFromCharacter(hitCharacter)
		local hitHumanoid = hitCharacter:FindFirstChildOfClass("Humanoid")
		local totalDamage = 0

		--[[
			Player1: {
				Neutral: true,
				Team: nil
			}
			Player2: {
				Neutral: true,
				Team: nil
			} 
		]]

		if hitPlayer and Config.Teamkill == false then
			if hitPlayer.TeamColor == player.TeamColor and (hitPlayer.Neutral ~= true or player.Neutral ~= true) then
				return
			end
		end

		if hitHumanoid then
			local damages = config.Damage

			totalDamage += if instance.Name == "Head" then damages.Head else damages.Body
			
			if (hitHumanoid.Health - totalDamage) < 0 then
				local creator_tag = Instance.new("ObjectValue")
				creator_tag.Name = "creator"
				creator_tag.Value = player
				creator_tag.Parent = hitHumanoid
				game.Debris:AddItem(creator_tag, 0.5)
			end
			
			hitHumanoid:TakeDamage(totalDamage)
			


			return { TotalDamage = totalDamage }
		end
	end

	return
end


--[[
Unused

local function makeTracerInvisible(tracer)
	for _, v in pairs(tracer:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
		makeTracerInvisible(v)
	end
end
]]

function GunHandler:_checkFire(player: Player, gunTool: Tool): boolean
	local config = GunUtil:GetConfig(gunTool)

	local fireCount = self._fireCount[player][gunTool]
	if fireCount then
		return fireCount < config.Ammo
	end

	return false
end

function GunHandler:_createMotor6D(character: Types.PlayerCharacter)
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 9e9) :: BasePart
	local rightArm = character:WaitForChild("Right Arm", 9e9) :: BasePart

	local motor6D = Instance.new("Motor6D")
	motor6D.Name = "GunMotor6D"
	motor6D.Part0 = rightArm
	motor6D.Parent = humanoidRootPart

	self._motor6D[character] = motor6D
end


function GunHandler:Destroy() end

return GunHandler
task.wait(3)

local GunHandler = script.Handlers.GunHandler

local checkpart = Instance.new("Part", game.ServerStorage)
checkpart.Name = "GunSysCheckPart"
checkpart.Position = Vector3.new(125, 20, 2)
checkpart.Size = Vector3.new(414, 113, 12)


require(GunHandler).new(checkpart)


-----------------------------------------------------------------------------------------
----------------------------- Slider Module -----------------------------
-- [Author]: Krypt
-- [Description]: Creates a slider based on a start, end and incremental value. Allows ...
-- ... sliders to be moved, tracked/untracked, reset, and have specific properties such ...
-- ... as their current value and increment to be overriden.

-- [Version]: 2.0.1
-- [Created]: 22/12/2021
-- [Updated]: 15/08/2022
-- [Dev Forum Link]: https://devforum.roblox.com/t/1597785/
-----------------------------------------------------------------------------------------

--!nonstrict
local Slider = {Sliders = {}}

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

assert(RunService:IsClient(), "Slider module can only be used on the Client!")

local Clamp = math.clamp
local Floor = math.floor
local Min = math.min
local Max = math.max
local Round = math.round
local Abs = math.abs

local Lower = string.lower
local Upper = string.upper
local Sub = string.sub
local Format = string.format

local utilsFolder = script.Utils

local Signal = require(utilsFolder.Signal)
local Switch = require(utilsFolder.Switch)
local VectorFuncs = require(utilsFolder.VectorFuncs)
local SliderFuncs = require(utilsFolder.SliderFuncs)

Slider.__index = function(object, indexed)
	local deprecated = {
		{".OnChange", ".Changed", rawget(object, "Changed")}
	}

	for _, tbl in ipairs(deprecated) do
		local deprecatedStr = Sub(tbl[1], 2)

		if deprecatedStr == indexed then
			warn(Format("%s is deprecated, please use %s instead", tbl[1], tbl[2]))
			return tbl[3]	
		end
	end

	return Slider[indexed]
end

export type configDictionary = {
	SliderData: {Start: number, End: number, Increment: number, DefaultValue: number | nil},
	MoveType: "Tween" | "Instant" | nil,
	MoveInfo: TweenInfo | nil,
	Axis: string | nil,
	Padding: number | nil
}

function Slider.new(holder: GuiBase2d, config: configDictionary)
	assert(pcall(function()
		return holder.AbsoluteSize, holder.AbsolutePosition
	end), "Holder argument does not have an AbsoluteSize/AbsolutePosition")
	
	local duplicate = false
	for _, slider in ipairs(Slider.Sliders) do
		if slider._holder == holder then
			duplicate = true
			break
		end
	end
	
	assert(not duplicate, "Cannot set two sliders with same frame!")
	assert(config.SliderData.Increment ~= nil, "Failed to find Increment in SliderData table")
	assert(config.SliderData.Start ~= nil, "Failed to find Start in SliderData table")
	assert(config.SliderData.End ~= nil, "Failed to find End in SliderData table")
	assert(config.SliderData.Increment > 0, "SliderData.Increment must be greater than 0")
	assert(config.SliderData.End > config.SliderData.Start, Format("Slider end value must be greater than its start value! (%.1f <= %.1f)", config.SliderData.End, config.SliderData.Start))
	
	local self = setmetatable({}, Slider)
	self._holder = holder
	self._data = {
		Button = nil,
		HolderButton = nil,
		
		UiType = nil,
		HolderPart = nil,
		SurfaceGui = nil,
		
		CLICK_OVERRIDE = false,
		_mainConnection = nil,
		_miscConnections = {},
		_inputPos = nil,
		
		_percent = 0,
		_value = 0,
		_scaleIncrement = 0,
		_currentTween = nil
	}
	
	self._config = config
	self._config.Axis = Upper(config.Axis or "X")
	self._config.Padding = config.Padding or 5
	self._config.MoveInfo = config.MoveInfo or TweenInfo.new(0.2)
	self._config.MoveType = config.MoveType or "Tween"
	self.IsHeld = false
	
	local sliderBtn = holder:FindFirstChild("Slider")
	assert(sliderBtn ~= nil, "Failed to find slider button.")
	assert(sliderBtn:IsA("GuiButton"), "Slider is not a GuiButton")
	
	self._data.Button = sliderBtn
	
	-- Holder button --
	local holderClickButton = Instance.new("TextButton")
	holderClickButton.BackgroundTransparency = 1
	holderClickButton.Text = ""
	holderClickButton.Name = "HolderClickButton"
	holderClickButton.Size = UDim2.fromScale(1, 1)
	holderClickButton.ZIndex = -1
	holderClickButton.Parent = self._holder
	
	self._data.HolderButton = holderClickButton
	
	-- Finalise --
	
	self._data.UiType = if 
		holder:FindFirstAncestorOfClass("ScreenGui") then "ScreenGui" 
		elseif holder:FindFirstAncestorOfClass("SurfaceGui") then "SurfaceGui"
		else nil

	self._data.HolderPart = Switch(self._data.UiType) {
		["SurfaceGui"] = holder:FindFirstAncestorWhichIsA("BasePart"),
		["ScreenGui"] = nil
	}
	self._data.SurfaceGui = Switch(self._data.UiType) {
		["SurfaceGui"] = holder:FindFirstAncestorWhichIsA("SurfaceGui"),
		["ScreenGui"] = nil
	}
	
	self._data._percent = 0
	if config.SliderData.DefaultValue then
		config.SliderData.DefaultValue = Clamp(config.SliderData.DefaultValue, config.SliderData.Start, config.SliderData.End)
		self._data._percent = SliderFuncs.getAlphaBetween(config.SliderData.Start, config.SliderData.End, config.SliderData.DefaultValue) 
	end
	
	self._data._percent = Clamp(self._data._percent, 0, 1)

	self._data._value = SliderFuncs.getNewValue(self)
	self._data._scaleIncrement = SliderFuncs.getScaleIncrement(self)
	
	self.Changed = Signal.new()
	self.Dragged = Signal.new()
	self.Released = Signal.new()
	
	self:Move()
	table.insert(Slider.Sliders, self)
	
	return self
end

function Slider:Track()
	for _, connection in ipairs(self._data._miscConnections) do
		connection:Disconnect()
	end

	table.insert(self._data._miscConnections, self._data.Button.MouseButton1Down:Connect(function()
		self.IsHeld = true
	end))

	table.insert(self._data._miscConnections, self._data.Button.MouseButton1Up:Connect(function()
		if self.IsHeld then
			self.Released:Fire(self._data._value)
		end
		self.IsHeld = false
	end))

	table.insert(self._data._miscConnections, self._data.HolderButton.Activated:Connect(function(inputObject: InputObject)
		if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
			self._data._inputPos = inputObject.Position
			self._data.CLICK_OVERRIDE = true
			self:Update()
			self._data.CLICK_OVERRIDE = false
		end
	end))

	if self.Changed then
		self.Changed:Fire(self._data._value)
	end

	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	self._data._mainConnection = UserInputService.InputChanged:Connect(function(inputObject, gameProcessed)
		if inputObject.UserInputType == Enum.UserInputType.MouseMovement or inputObject.UserInputType == Enum.UserInputType.Touch then
			self._data._inputPos = inputObject.Position
			self:Update()
		end
	end)
end

function Slider:Update()
	if (self.IsHeld and not self._data.CLICK_OVERRIDE) and self._data._inputPos then
		local mousePos = Switch(self._data.UiType) {
			["ScreenGui"] = self._data._inputPos[self._config.Axis],

			["SurfaceGui"] = function()
				local rayParams = RaycastParams.new()
				rayParams.FilterType = Enum.RaycastFilterType.Whitelist
				rayParams.FilterDescendantsInstances = {self._data.HolderPart}

				local unitRay = workspace.CurrentCamera:ScreenPointToRay(self._data._inputPos.X, self._data._inputPos.Y)
				local hitResult = workspace:Raycast(unitRay.Origin, unitRay.Direction * 500, rayParams)

				if hitResult then
					local hitPart = hitResult.Instance
					local hitPos = hitResult.Position
					local hitNormal = hitResult.Normal

					if VectorFuncs.normalVectorToFace(hitPart, hitNormal) ~= self._data.SurfaceGui.Face then
						return
					end

					local hitCF = CFrame.new(hitPos, hitPos + hitNormal)

					local topLeftCorners = VectorFuncs.getTopLeftCorners(hitPart)
					local topLeftCFrame = topLeftCorners[self._data.SurfaceGui.Face]

					local hitOffset = topLeftCFrame:ToObjectSpace(hitCF)
					local mappedOffset = VectorFuncs.mapOffsetToFace(hitOffset, self._config.Axis, self._data.SurfaceGui.Face)

					local relativePos = Vector2.new(
						Abs(mappedOffset.X) * self._data.SurfaceGui.PixelsPerStud, 
						Abs(mappedOffset.Y) * self._data.SurfaceGui.PixelsPerStud
					)

					return relativePos[self._config.Axis]
				end
			end
		}

		if mousePos then
			local sliderSize = self._holder.AbsoluteSize[self._config.Axis]
			local sliderPos = self._holder.AbsolutePosition[self._config.Axis]
			local newPos = SliderFuncs.snapToScale((mousePos - sliderPos) / sliderSize, self._data._scaleIncrement)

			local percent = Clamp(newPos, 0, 1)

			self._data._percent = percent
			self.Dragged:Fire(self._data._value)
			self:Move()
		end
	end
end

function Slider:Untrack()
	for _, connection in ipairs(self._data._miscConnections) do
		connection:Disconnect()
	end
	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end
	self.IsHeld = false
end

function Slider:Reset()
	for _, connection in ipairs(self._data._miscConnections) do
		connection:Disconnect()
	end
	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	self.IsHeld = false

	self._data._percent = 0
	if self._config.SliderData.DefaultValue then 
		self._data._percent = SliderFuncs.getAlphaBetween(self._config.SliderData.Start, self._config.SliderData.End, self._config.SliderData.DefaultValue)
	end
	self._data._percent = Clamp(self._data._percent, 0, 1)
	self:Move()
end

function Slider:OverrideValue(newValue: number)
	self.IsHeld = false
	self._data._percent = SliderFuncs.getAlphaBetween(self._config.SliderData.Start, self._config.SliderData.End, newValue)
	self._data._percent = Clamp(self._data._percent, 0, 1)
	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()
end

function Slider:Move()
	self._data._value = SliderFuncs.getNewValue(self)

	Switch(self._config.MoveType) {
		[{"Tween", nil}] = function()
			if self._data._currentTween then
				self._data._currentTween:Cancel()
			end
			self._data._currentTween = TweenService:Create(self._data.Button, self._config.MoveInfo, {
				Position = SliderFuncs.getNewPosition(self)
			})
			self._data._currentTween:Play()
		end,
		
		["Instant"] = function()
			self._data.Button.Position = SliderFuncs.getNewPosition(self)
		end,
		
		["Default"] = function()
			print("Uh")
		end,
	}
	self.Changed:Fire(self._data._value)
end

function Slider:OverrideIncrement(newIncrement: number)
	self._config.SliderData.Increment = newIncrement
	self._data._scaleIncrement = SliderFuncs.getScaleIncrement(self)
	self._data._percent = Clamp(self._data._percent, 0, 1)
	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()
end

function Slider:GetValue()
	return self._data._value
end

function Slider:GetIncrement()
	return self._data._increment
end

function Slider:Destroy()
	for _, connection in ipairs(self._data._miscConnections) do
		connection:Disconnect()
	end

	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	self.Changed:Destroy()
	self.Dragged:Destroy()
	self.Released:Destroy()

	for index = 1, #Slider.Sliders do
		if Slider.Sliders[index] == self then
			table.remove(Slider.Sliders, index)
		end
	end

	setmetatable(self, nil)
	self = nil
end

UserInputService.InputEnded:Connect(function(inputObject: InputObject, internallyProcessed: boolean)
	if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
		for _, slider in ipairs(Slider.Sliders) do
			if slider.IsHeld then
				slider.Released:Fire(slider._data._value)
			end
			slider.IsHeld = false
		end
	end 
end)
	
return Slider
-----------------------------------------------------------------------------------------




return function(condition)
	return function(cases)
		local found = false
		local result
		
		for key, val in pairs(cases) do
			if found then break end
			
			if type(key) == "table" then
				for _, condKey in ipairs(key) do
					if condKey == condition then
						found = true
						result = val
						break
					end
				end
			else
				if key == condition then
					found = true
					result = val
					break
				end
			end
		end
		
		if not found then
			result = cases.default
		end
		
		if result then
			return if type(result) == "function" then result() else result
		end
	end
end

local SliderFuncs = {}

local Switch = require(script.Parent:WaitForChild("Switch"))

local Clamp = math.clamp
local Floor = math.floor
local Min = math.min
local Max = math.max
local Round = math.round
local Abs = math.abs

function SliderFuncs.snapToScale(val: number, step: number): number
	return Clamp(Round(val / step) * step, 0, 1)
end

function lerp(start: number, finish: number, percent: number): number
	return (1 - percent) * start + percent * finish
end

function map(value: number, start: number, stop: number, newStart: number, newEnd: number, constrain: boolean): number
	local newVal = lerp(newStart, newEnd, SliderFuncs.getAlphaBetween(start, stop, value))
	if not constrain then
		return newVal
	end

	if newStart < newEnd then
		newStart, newEnd = newEnd, newStart
	end

	return Max(Min(newVal, newStart), newEnd)
end

function SliderFuncs.getNewPosition(self): UDim2
	local absoluteSize = self._data.Button.AbsoluteSize[self._config.Axis]
	local holderSize = self._holder.AbsoluteSize[self._config.Axis]

	local anchorPoint = self._data.Button.AnchorPoint[self._config.Axis]

	local paddingScale = (self._config.Padding / holderSize)

	local minScale = (
		(anchorPoint * absoluteSize) / holderSize +
			paddingScale
	)

	local decrement = ((2 * absoluteSize) * anchorPoint) - absoluteSize
	local maxScale = (1 - minScale) + (decrement / holderSize)

	local newPercent = map(self._data._percent, 0, 1, minScale, maxScale, true)

	return Switch(self._config.Axis) {
		["X"] = UDim2.fromScale(newPercent, self._data.Button.Position.Y.Scale),
		["Y"] = UDim2.fromScale(self._data.Button.Position.X.Scale, newPercent)
	}
end

function SliderFuncs.getScaleIncrement(self)
	return 1 / ((self._config.SliderData.End - self._config.SliderData.Start) / self._config.SliderData.Increment)
end

function SliderFuncs.getAlphaBetween(a: number, b: number, c: number): number
	return (c - a) / (b - a)
end

function SliderFuncs.getNewValue(self)
	local newValue = lerp(self._config.SliderData.Start, self._config.SliderData.End, self._data._percent)
	local incrementScale = (1 / self._config.SliderData.Increment)

	newValue = Floor(newValue * incrementScale) / incrementScale
	return newValue
end

return SliderFuncs


----------------------------- Signal Module -----------------------------
-- > Used to create, connect, wait and destroy signals.
-- > Created by Quenty
-----------------------------------------------------------------------------------------

--- Lua-side duplication of the API of events on Roblox objects.
-- Signals are needed for to ensure that for local events objects are passed by
-- reference rather than by value where possible, as the BindableEvent objects
-- always pass signal arguments by value, meaning tables will be deep copied.
-- Roblox's deep copy method parses to a non-lua table compatable format.
-- @classmod Signal

local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"

--- Constructs a new signal.
-- @constructor Signal.new()
-- @treturn Signal
function Signal.new()
	local self = setmetatable({}, Signal)

	self._bindableEvent = Instance.new("BindableEvent")
	self._argData = nil
	self._argCount = nil -- Prevent edge case of :Fire("A", nil) --> "A" instead of "A", nil

	return self
end

--- Fire the event with the given arguments. All handlers will be invoked. Handlers follow
-- Roblox signal conventions.
-- @param ... Variable arguments to pass to handler
-- @treturn nil
function Signal:Fire(...)
	self._argData = {...}
	self._argCount = select("#", ...)
	self._bindableEvent:Fire()
	self._argData = nil
	self._argCount = nil
end

--- Connect a new handler to the event. Returns a connection object that can be disconnected.
-- @tparam function handler Function handler called with arguments passed when `:Fire(...)` is called
-- @treturn Connection Connection object that can be disconnected
function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end

	return self._bindableEvent.Event:Connect(function()
		handler(unpack(self._argData, 1, self._argCount))
	end)
end

--- Wait for fire to be called, and return the arguments it was given.
-- @treturn ... Variable arguments from connection
function Signal:Wait()
	self._bindableEvent.Event:Wait()
	assert(self._argData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
	return unpack(self._argData, 1, self._argCount)
end

--- Disconnects all connected events to the signal. Voids the signal as unusable.
-- @treturn nil
function Signal:Destroy()
	if self._bindableEvent then
		self._bindableEvent:Destroy()
		self._bindableEvent = nil
	end

	self._argData = nil
	self._argCount = nil
end

return Signal

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Signal = require(ReplicatedStorage.GunShared.Packages.Signal)

export type CameraTypes = "FPS" | "TPS"
export type Firemodes = "Single" | "Auto"

export type Effects = {
	CreateBullet: (origin: Vector3, direction: Vector3, ignoreInstances: { Instance }) -> Caster,
	MaterialHit: (raycastResult: RaycastResult) -> (),
	BarrelFire: (barrel: Attachment, soundId: number) -> (),
	CreateShell: (bulletType: string, origin: CFrame, direction: Vector3) -> (),
	PlaySound: (id: number, position: Vector3?, volume: number?) -> Sound?,
}

export type Caster = {
	RayHit: Signal.Signal<RaycastResult>,
	PositionChanged: Signal.Signal<Vector3, number>,
	CastTerminating: Signal.Signal<...any>,
	Fire: (self: Caster, origin: Vector3, direction: Vector3, velocity: number?, raycastParams: RaycastParams?) -> (),
	Destroy: (self: Caster) -> (),
}

export type HitResult = {
	TotalDamage: number,
}

export type ReplicaBulletResult = {
	Origin: Vector3,
	Direction: Vector3,
	GunTool: Tool,
	Character: PlayerCharacter,
	IgnoreInstances: { Instance },
	WallRaycastResult: RaycastResult?,
	OnRayHit: ((RaycastResult) -> ())?,
}

export type GunConfig = {
	Ammo: number,
	HandleOffset: CFrame?,
	Fire: {
		Rate: number,
		Spread: number,
		Mode: { Value: Firemodes, Change: boolean },
		AimWeight: number,
	},
	Bullet: { Type: string, Range: { number }, Up: { number } },
	Damage: { Head: number, Body: number },
	Aim: { FOV: number },
	Sounds: { Fire: number, Reload: number },
}

export type PlayerCharacter = {
	BodyColors: BodyColors,
	Humanoid: {
		HumanoidDescription: HumanoidDescription,
		Status: Status,
		Animator: Animator,
	} & Humanoid,
	Pants: Pants?,
	Shirt: Shirt?,
	Head: BasePart,
	HumanoidRootPart: BasePart,
	Torso: BasePart,
	["Right Arm"]: BasePart,
	["Left Arm"]: BasePart,
	["Left Leg"]: BasePart,
	["Right Leg"]: BasePart,
} & Model

export type ViewModel = {
	BodyColors: BodyColors,
	Humanoid: {
		Animator: Animator,
	} & Humanoid,
	Pants: Pants?,
	Shirt: Shirt?,
	Head: BasePart,
	HumanoidRootPart: BasePart,
	Torso: BasePart,
	["Right Arm"]: BasePart,
	["Left Arm"]: BasePart,
} & Model

return nil
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Signal = require(ReplicatedStorage.GunShared.Packages.Signal)

export type Value<T> = {
	Value: T,
	Changed: Signal.Signal<T>,
	Observe: (self: Value<T>, fn: (T) -> ()) -> (),
}

local Value = {}

function Value.new<T>(initValue: T): Value<T>
	local self = setmetatable({
		_value = initValue,

		Changed = Signal.new(),
	}, Value)

	return self
end

function Value:_set(newValue)
	self._value = newValue
	self.Changed:Fire(newValue)
end

function Value:Observe(fn)
	task.spawn(fn, self._value)
	return self.Changed:Connect(fn)
end

function Value:__index(index)
	if index == "Value" then
		return self._value
	else
		return rawget(Value, index)
	end
end

function Value:__newindex(index, value)
	if index == "Value" then
		if self._value == value then
			return
		end

		self:_set(value)
	end
end

function Value:Destroy()
	rawset(self, "_value", nil)
	self.Changed:Destroy()
	setmetatable(self, nil)
end

return Value
-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	```lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})
--[=[
	A physical model of a spring, useful in many applications.
	A spring is an object that will compute based upon Hooke's law. Properties only evaluate
	upon index making this model good for lazy applications.
	```lua
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local spring = Spring.new(Vector3.new(0, 0, 0))
	RunService.RenderStepped:Connect(function()
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			spring.Target = Vector3.new(0, 0, 1)
		else
			spring.Target = Vector3.new(0, 0, 0)
		end
		print(spring.Position) -- A smoothed out version of the input keycode W
	end)
	```
	A good visualization can be found here, provided by Defaultio:
	https://www.desmos.com/calculator/hn2i9shxbz
	@class Spring
]=]
local Spring = {}

--[=[
	Constructs a new Spring at the position and target specified, of type T.
	```lua
	-- Linear spring
	local linearSpring = Spring.new(0)
	-- Vector2 spring
	local vector2Spring = Spring.new(Vector2.new(0, 0))
	-- Vector3 spring
	local vector3Spring = Spring.new(Vector3.new(0, 0, 0))
	```
	@param initial T -- The initial parameter is a number or Vector3 (anything with * number and addition/subtraction).
	@param clock? () -> number -- The clock function is optional, and is used to update the spring
	@return Spring<T>
]=]
function Spring.new(initial, clock)
	local target = initial or 0
	clock = clock or os.clock
	return setmetatable({
		_clock = clock,
		_time0 = clock(),
		_position0 = target,
		_velocity0 = 0 * target,
		_target = target,
		_damper = 1,
		_speed = 1,
	}, Spring)
end

--[=[
	Impulses the spring, increasing velocity by the amount given. This is useful to make something shake,
	like a Mac password box failing.
	@param velocity T -- The velocity to impulse with
	@return ()
]=]
function Spring:Impulse(velocity)
	self.Velocity = self.Velocity + velocity
end

--[=[
	Instantly skips the spring forwards by that amount time
	@param delta number -- Time to skip forwards
	@return ()
]=]
function Spring:TimeSkip(delta)
	local now = self._clock()
	local position, velocity = self:_positionVelocity(now + delta)
	self._position0 = position
	self._velocity0 = velocity
	self._time0 = now
end

--[=[
	The current position at the given clock time. Assigning the position will change the spring to have that position.
	```lua
	local spring = Spring.new(0)
	print(spring.Position) --> 0
	```
	@prop Position T
	@within Spring
]=]
--[=[
	Alias for [Spring.Position](/api/Spring#Position)
	@prop p T
	@within Spring
]=]
--[=[
	The current velocity. Assigning the velocity will change the spring to have that velocity.
	```lua
	local spring = Spring.new(0)
	print(spring.Velocity) --> 0
	```
	@prop Velocity T
	@within Spring
]=]
--[=[
	Alias for [Spring.Velocity](/api/Spring#Velocity)
	@prop v T
	@within Spring
]=]
--[=[
	The current target. Assigning the target will change the spring to have that target.
	```lua
	local spring = Spring.new(0)
	print(spring.Target) --> 0
	```
	@prop Target T
	@within Spring
]=]
--[=[
	Alias for [Spring.Target](/api/Spring#Target)
	@prop t T
	@within Spring
]=]
--[=[
	The current damper, defaults to 1. At 1 the spring is critically damped. At less than 1, it
	will be underdamped, and thus, bounce, and at over 1, it will be critically damped.
	@prop Damper number
	@within Spring
]=]
--[=[
	Alias for [Spring.Damper](/api/Spring#Damper)
	@prop d number
	@within Spring
]=]
--[=[
	The speed, defaults to 1, but should be between [0, infinity)
	@prop Speed number
	@within Spring
]=]
--[=[
	Alias for [Spring.Speed](/api/Spring#Speed)
	@prop s number
	@within Spring
]=]
--[=[
	The current clock object to syncronize the spring against.
	@prop Clock () -> number
	@within Spring
]=]
function Spring:__index(index)
	if Spring[index] then
		return Spring[index]
	elseif index == "Value" or index == "Position" or index == "p" then
		local position, _ = self:_positionVelocity(self._clock())
		return position
	elseif index == "Velocity" or index == "v" then
		local _, velocity = self:_positionVelocity(self._clock())
		return velocity
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damper" or index == "d" then
		return self._damper
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:__newindex(index, value)
	local now = self._clock()

	if index == "Value" or index == "Position" or index == "p" then
		local _, velocity = self:_positionVelocity(now)
		self._position0 = value
		self._velocity0 = velocity
		self._time0 = now
	elseif index == "Velocity" or index == "v" then
		local position, _ = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = value
		self._time0 = now
	elseif index == "Target" or index == "t" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._target = value
		self._time0 = now
	elseif index == "Damper" or index == "d" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._damper = value
		self._time0 = now
	elseif index == "Speed" or index == "s" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._speed = value < 0 and 0 or value
		self._time0 = now
	elseif index == "Clock" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._clock = value
		self._time0 = value()
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:_positionVelocity(now)
	local p0 = self._position0
	local v0 = self._velocity0
	local p1 = self._target
	local d = self._damper
	local s = self._speed

	local t = s * (now - self._time0)
	local d2 = d * d

	local h, si, co
	if d2 < 1 then
		h = math.sqrt(1 - d2)
		local ep = math.exp(-d * t) / h
		co, si = ep * math.cos(h * t), ep * math.sin(h * t)
	elseif d2 == 1 then
		h = 1
		local ep = math.exp(-d * t) / h
		co, si = ep, ep * t
	else
		h = math.sqrt(d2 - 1)
		local u = math.exp((-d + h) * t) / (2 * h)
		local v = math.exp((-d - h) * t) / (2 * h)
		co, si = u + v, u - v
	end

	local a0 = h * co + d * si
	local a1 = 1 - (h * co + d * si)
	local a2 = si / s

	local b0 = -s * si
	local b1 = s * si
	local b2 = h * co - d * si

	return a0 * p0 + a1 * p1 + a2 * v0, b0 * p0 + b1 * p1 + b2 * v0
end

return Spring

--[=[
	Manages the cleaning of events and other things. Useful for
	encapsulating state and make deconstructors easy.

	See the [Five Powerful Code Patterns talk](https://developer.roblox.com/en-us/videos/5-powerful-code-patterns-behind-top-roblox-games)
	for a more in-depth look at Maids in top games.

	```lua
	local maid = Maid.new()

	maid:GiveTask(function()
		print("Cleaning up")
	end)

	maid:GiveTask(workspace.ChildAdded:Connect(print))

	-- Disconnects all events, and executes all functions
	maid:DoCleaning()
	```

	@class Maid
]=]
-- luacheck: pop

local Maid = {}
Maid.ClassName = "Maid"
Maid.__index = Maid

--[=[
	Constructs a new Maid object

	```lua
	local maid = Maid.new()
	```

	@return Maid
]=]
function Maid.new()
	return setmetatable({
		_tasks = {},
	}, Maid)
end

--[=[
	Returns true if the class is a maid, and false otherwise.

	```lua
	print(Maid.isMaid(Maid.new())) --> true
	print(Maid.isMaid(nil)) --> false
	```

	@param value any
	@return boolean
]=]
function Maid.isMaid(value)
	return type(value) == "table" and value.ClassName == "Maid"
end

--[=[
	Gives a task to the maid for cleanup and returnsthe resulting value

	@param task MaidTask -- An item to clean
	@return MaidTask
]=]
function Maid:Add<T>(task: T): T
	self:GiveTask(task)

	return task
end

--[=[
	Gives a task to the maid for cleanup, but uses an incremented number as a key.

	@param task MaidTask -- An item to clean
	@return number -- taskId
]=]
function Maid:GiveTask(task)
	if not task then
		error("Task cannot be false or nil", 2)
	end

	local taskId = #self._tasks + 1
	self._tasks[taskId] = task

	if type(task) == "table" and not task.Destroy then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

--[=[
	Gives a promise to the maid for clean.

	@param promise Promise<T>
	@return Promise<T>
]=]
function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self._tasks[id] = nil
	end)

	return newPromise
end

--[=[
	Cleans up all tasks and removes them as entries from the Maid.

	:::note
	Signals that are already connected are always disconnected first. After that
	any signals added during a cleaning phase will be disconnected at random times.
	:::

	:::tip
	DoCleaning() may be recursively invoked. This allows the you to ensure that
	tasks or other tasks. Each task will be executed once.

	However, adding tasks while cleaning is not generally a good idea, as if you add a
	function that adds itself, this will loop indefinitely.
	:::
]=]
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in tasks do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil

		if typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		elseif type(job) == "function" then
			job()
		elseif typeof(job) == "thread" then
			local success
			if coroutine.running() ~= job then
				success = pcall(task.cancel, job)
			end

			if not success then
				task.defer(function()
					if job then
						task.cancel(job)
					end
				end)
			end
		elseif typeof(job) == "Instance" and job:IsA("AnimationTrack") then
			job:Stop()
			job:Destroy()
		elseif job.Destroy then
			job:Destroy()
		end

		index, job = next(tasks)
	end
end

--[=[
	Alias for [Maid.DoCleaning()](/api/Maid#DoCleaning)

	@function Destroy
	@within Maid
]=]
Maid.Destroy = Maid.DoCleaning

return Maid
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local wallyInstanceManager = {}

function wallyInstanceManager.add(project: Instance, targetInstance: Instance)
	if not ReplicatedStorage:FindFirstChild(project.Name) then
		local folder = Instance.new("Folder")
		folder.Name = project.Name
		folder.Parent = ReplicatedStorage
	end

	targetInstance.Parent = ReplicatedStorage:FindFirstChild(project.Name)
end

function wallyInstanceManager.get(project: Instance, instanceName: string)
	return if ReplicatedStorage:FindFirstChild(project.Name) ~= nil
		then ReplicatedStorage[project.Name]:FindFirstChild(instanceName)
		else nil
end

function wallyInstanceManager.waitForInstance(project: Instance, instanceName: string, maxTimeout: number)
	local projectFolder = ReplicatedStorage:WaitForChild(project.Name)

	return projectFolder:WaitForChild(instanceName, maxTimeout or 1)
end

return wallyInstanceManager


return "1.0.0"




--!strict
export type Set<T> = { [T]: true | false }
export type Array<T> = { [number]: T }
export type Callback = (...unknown) -> ()
export type Map<T, K> = { [T]: K }

export type MetaMessage = "1"

export type ServerConnectionCallback = (Player, Content) -> ()
export type Content = unknown
export type Identifier = string

-- Player containers
export type PlayerContainerTypes = "all" | "set" | "except" | "single"

export type SetPlayerContainer = {
	kind: "set",
	value: Array<Player>,
}

export type ExceptPlayerContainer = {
	kind: "except",
	value: { [number]: Player },
}

export type SinglePlayerContainer = {
	kind: "single",
	value: Player,
}

export type AllPlayerContainer = {
	kind: "all",
	value: nil,
}

export type PlayerContainer = SetPlayerContainer | ExceptPlayerContainer | SinglePlayerContainer | AllPlayerContainer

export type PlayerContainerIndexes = {
	All: () -> AllPlayerContainer,
	Except: (excludedPlayers: Array<Player>) -> ExceptPlayerContainer,
	Single: (player: Player) -> SinglePlayerContainer,
	Players: (players: Array<Player>) -> SetPlayerContainer,
}

export type ServerInboundPacket = {}
export type ServerOutboundPacket = {
	playerContainer: PlayerContainer,
	content: unknown,
	id: Identifier,
}

return nil



local TableKit = {}

--[=[
	This function "deep" copies a table, and all of its contents. This means that it will clone the entire table,
	and tables within that table- as opposed to shallow-copying with table.clone
	
	```lua
	local Dictionary = {
		SomethingInside = {
			A = 1,
			B = 2,
		},
	}
	
	local CopiedDictionary = TableKit.DeepCopy(Dictionary)
	
	print(CopiedDictionary) -- prints { ["SomethingInside"] = { ["A"] = 1, ["B"] = 1 } }
	```
	
	:::caution Recursive Function
	This function is recursive- this can cause stack overflows.

	@within TableKit
	@param tableToClone table
	@return table
]=]
function TableKit.DeepCopy<T>(tableToClone: { [unknown]: unknown }): T
	local clone = table.clone(tableToClone)
	for index, value in clone do
		if typeof(value) == "table" then
			clone[index] = TableKit.DeepCopy(value :: { [unknown]: unknown })
		end
	end
	return clone
end

--[=[
	This function merges two dictionaries.

	Keys *will* overwrite- if there are duplicate keys, dictionary2 will take priority.

	```lua
	local Dictionary = {
		A = 1,
		B = 2,
	}
	local SecondDictionary = {
		C = 3,
		D = 4,
	}
	
	print(TableKit.MergeDictionary(Dictionary, SecondDictionary)) -- prints { ["A"] = 1, ["B"] = 2, ["C"] = 3, ["D"] = 4 }
	```
	
	:::caution Potential overwrite
	Keys are overwritten when using .MergeDictionary()
	
	@within TableKit
	@param dictionary1 table
	@param dictionary2 table
	@return table
]=]
function TableKit.MergeDictionary<dictionary1, dictionary2>(
	dictionary1: { [unknown]: unknown },
	dictionary2: { [unknown]: unknown }
): dictionary1 & dictionary2
	local newTable = table.clone(dictionary1)

	for key, value in dictionary2 do
		newTable[key] = value
	end

	return newTable
end

--[=[
	This function returns a table with the keys of the passed dictionary.
	
	```lua
	local Dictionary = {
		A = 1,
		B = 2,
		C = 3,
	}
	
	print(TableKit.Keys(Dictionary)) -- prints {"A", "B", "C"}
	```

	@within TableKit
	@param dictionary table
	@return table
]=]
function TableKit.Keys(dictionary: { [unknown]: unknown }): { unknown }
	local keyArray = {}

	for key in dictionary do
		table.insert(keyArray, key)
	end

	return keyArray
end

--[=[
	This function returns a table with the values of the passed dictionary.
	
	```lua
	local Dictionary = {
		A = 1,
		B = 2,
		C = 3,
	}
	
	print(TableKit.Values(Dictionary)) -- prints {1, 2, 3}
	```

	@within TableKit
	@param dictionary table
	@return table
]=]
function TableKit.Values<T>(dictionary: { [unknown]: T }): { T }
	local valueArray = {}

	for _, value in dictionary do
		table.insert(valueArray, value)
	end

	return valueArray
end

--[=[
	Merges two arrays; array2 will be added to array1- this means that the indexes of array1 will be the same.
	
	```lua
	local FirstArray = {"A", "B", "C", "D"}
	local SecondArray = {"E", "F", "G", "H"}
	
	print(TableKit.MergeArrays(FirstArray, SecondArray)) -- prints {"A", "B", "C", D", "E", "F", "G", "H"}
	```

	@within TableKit
	@param array1 table
	@param array2 table
	@return table
]=]
function TableKit.MergeArrays<a, b>(a: { unknown }, b: { unknown }): a & b
	local result = table.clone(a)
	table.move(b, 1, #b, #result + 1, result)
	return result
end

--[=[
	Deep-reconciles a dictionary into another dictionary.
	
	```lua
	local template = {
		A = 0,
		B = 0,
		C = {
			D = "",
		},
	}

	local toReconcile = {
		A = 9,
		B = 8,
		C = {},
	}
	
	print(TableKit.Reconcile(toReconcile, template)) -- prints { A = 9, B = 8, C = { D = "" }
	```

	@within TableKit
	@param original table
	@param reconcile table
	@return table
]=]
function TableKit.Reconcile(original: { [unknown]: unknown }, reconcile: { [unknown]: any })
	local tbl = table.clone(original)

	for key, value in reconcile do
		if tbl[key] == nil then
			if typeof(value) == "table" then
				tbl[key] = TableKit.DeepCopy(value)
			else
				tbl[key] = value
			end
		elseif typeof(reconcile[key]) == "table" then
			if typeof(value) == "table" then
				tbl[key] = TableKit.Reconcile(value, reconcile[key])
			else
				tbl[key] = TableKit.DeepCopy(reconcile[key])
			end
		end
	end

	return tbl
end

--[=[
	Detects if a table is an array, meaning purely number indexes and indexes starting at 1.
	
	```lua
	local Array = {"A", "B", "C", "D"}
	local Dictionary = { NotAnArray = true }
	
	print(TableKit.IsArray(Array), TableKit.IsArray(Dictionary)) -- prints true, false
	```

	@within TableKit
	@param mysteryTable table
	@return boolean
]=]
function TableKit.IsArray(mysteryTable: { [unknown]: unknown }): boolean
	local count = 0
	for _ in mysteryTable do
		count += 1
	end
	return count == #mysteryTable
end

--[=[
	Detects if a table is a dictionary, meaning it is not purely number indexes.
	
	```lua
	local Array = {"A", "B", "C", "D"}
	local Dictionary = { NotAnArray = true }
	
	print(TableKit.IsDictionary(Array), TableKit.IsDictionary(Dictionary)) -- prints false, true
	```

	@within TableKit
	@param mysteryTable table
	@return boolean
]=]
function TableKit.IsDictionary(mysteryTable: { [unknown]: unknown }): boolean
	local count = 0
	for _ in mysteryTable do
		count += 1
	end
	return count ~= #mysteryTable
end

--[=[
	Converts a table into a string.
	
	```lua
	local DictionaryA = {
		A = "Z",
		B = "X",
		C = "Y",
	}
	
	print(TableKit.ToString(DictionaryA)) -- prints {
							--			[A]: Z
							--			[C]: Y
							--			[B]: X
							--		 }
	```

	@within TableKit
	@param obj {}
	@return string
]=]
function TableKit.ToString(obj: { [unknown]: unknown }): string
	local result = {}
	for key, value in obj do
		local stringifiedKey
		if typeof(key) == "string" then
			stringifiedKey = `"{tostring(key)}"`
		else
			stringifiedKey = tostring(key)
		end

		local stringifiedValue
		local valueToString = tostring(value)
		if typeof(value) == "string" then
			stringifiedValue = `"{valueToString}"`
		else
			stringifiedValue = valueToString
		end

		local newline = `	[{stringifiedKey}] = {stringifiedValue}`
		table.insert(result, newline)
	end
	return "{\n" .. table.concat(result, "\n") .. "\n}"
end

function TableKit.ToArrayString(obj: { [number]: unknown }): string
	local result = {}
	for _, value in obj do
		local stringifiedValue
		local valueToString = tostring(value)
		if typeof(value) == "string" then
			stringifiedValue = `"{valueToString}"`
		else
			stringifiedValue = valueToString
		end

		table.insert(result, stringifiedValue)
	end
	return "{" .. table.concat(result, ", ") .. "}"
end

--[=[
	Takes in a data type, and returns it in array form.
	
	```lua
	local str = "Test"
	
	print(TableKit.From(str)) -- prints ("T", "e", "s", t")
	```

	@within TableKit
	@param value unknown
	@return { [number]: unknown }
]=]
function TableKit.From(value: any): { any }
	local valueType = typeof(value)
	if valueType == "string" then
		return string.split(value, "")
	elseif valueType == "Color3" then
		return { value.R, value.G, value.B }
	elseif valueType == "Vector2" then
		return { value.X, value.Y }
	elseif valueType == "Vector3" then
		return { value.X, value.Y, value.Z }
	elseif valueType == "NumberSequence" then
		return value.Keypoints
	elseif valueType == "Vector3int16" then
		return { value.X, value.Y, value.Z }
	elseif valueType == "Vector2int16" then
		return { value.X, value.Y }
	else
		return { value }
	end
end

--[=[
	Creates a shallow copy of an array, passed through a filter callback- if the callback returns false, the element is removed.
	
	```lua
	local str = {"a", "b", "c", "d", "e", "f", "g"}
	
	print(TableKit.Filter(str, function(value)
		return value > "c"
	end))
	-- prints {
 		[1] = "d",
 		[2] = "e",
 		[3] = "f",
 		[4] = "g"
 	}
	```

	@within TableKit
	@param arr { [number]: unknown }
	@param callback (value: value) -> boolean
	@return { [number]: unknown }
]=]
function TableKit.Filter<T>(arr: { [number]: T }, callback: (value: T) -> boolean)
	local tbl = {}

	for _, value in arr do
		if callback(value) then
			table.insert(tbl, value)
		end
	end

	return tbl
end

--[=[
	Loops through every single element, and puts it through a callback. If the callback returns true, the function returns true.
	
	```lua
	local array = {1, 2, 3, 4, 5}
	local even = function(value) return value % 2 == 0 end

	print(TableKit.Some(array, even)) -- Prints true
	```
	
	@within TableKit
	@param tbl table
	@param callback (value) -> boolean
	@return boolean
]=]
function TableKit.Some(tbl: { [unknown]: unknown }, callback: (value: unknown) -> boolean): boolean
	for _, value in tbl do
		if callback(value) == true then
			return true
		end
	end
	return false
end

--[=[
	Detects if a table has an embedded table as one of its members.
	
	```lua
	local Shallow = {"a", "b"}
	local Deep = {"a", {"b"}}
	
	print(TableKit.IsFlat(Shallow)) -- prints true
	print(TableKit.IsFlat(Deep)) -- prints false
	```
	
	@within TableKit
	@param tbl table
	@return boolean
]=]
function TableKit.IsFlat(tbl: { [unknown]: unknown }): boolean
	for _, v in tbl do
		if typeof(v) == "table" then
			return false
		end
	end
	return true
end

--[=[
	Loops through every single element, and puts it through a callback. If any of the conditions return false, the function returns false.
	
	```lua
	local array = {1, 2, 3, 4, 5}
	local even = function(value) return value % 2 == 0 end
	local odd = function(value) return value % 2 ~= 0 end
	
	print(TableKit.Every(array, even)) -- Prints false
	print(TableKit.Every(array, odd)) -- Prints false
	```
	
	@within TableKit
	@param tbl table
	@param callback (value) -> boolean
	@return boolean
]=]
function TableKit.Every(tbl: { [unknown]: unknown }, callback: (unknown) -> boolean): (boolean, unknown?)
	for key, value in tbl do
		if not callback(value) then
			return false, key
		end
	end
	return true
end

--[=[
	Detects if a dictionary has a certain key.
	
	```lua
	local Dictionary = {
		Hay = "A",
		MoreHay = "B",
		Needle = "C",
		SomeHay = "D",
	}
	
	print(TableKit.HasKey(Dictionary, "Needle")) -- prints true
	```
	
	@within TableKit
	@param dictionary table
	@param key unknown
	@return boolean
]=]
function TableKit.HasKey(dictionary: { [any]: unknown }, key: any): boolean
	return dictionary[key] ~= nil
end

--[=[
	Detects if a dictionary has a certain value.
	
	```lua
	local Array = { "Has", "this", "thing" }
	
	print(TableKit.HasValue(Array, "Has")) -- prints true
	```
	
	@within TableKit
	@param tbl table
	@param value unknown
	@return boolean
]=]
function TableKit.HasValue(tbl: { [unknown]: unknown }, value: unknown): boolean
	for _, v in tbl do
		if v == value then
			return true
		end
	end
	return false
end

--[=[
	Detects if a table is empty.
	
	```lua
	local Empty = {}
	local NotEmpty = { "Stuff" }
	
	print(TableKit.IsEmpty(Empty), TableKit.IsEmpty(NotEmpty)) -- prints true, false
	```

	@within TableKit
	@param mysteryTable table
	@return boolean
]=]
function TableKit.IsEmpty(mysteryTable: { [unknown]: unknown }): boolean
	return next(mysteryTable) == nil
end

return table.freeze(TableKit)
--!strict
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local HandleInvalidPlayer = require(script.Parent.HandleInvalidPlayer)
local Output = require(script.Parent.Parent.Utilities.Output)
local TableKit = require(script.Parent.Parent.TableKit)
local wallyInstanceManager = require(script.Parent.Parent.wallyInstanceManager)
local Types = require(script.Parent.Parent.Types)
local RecycledSpawn = require(script.Parent.Parent.Utilities.RecycledSpawn)
local version = require(script.Parent.Parent.version)
local ServerIdentifiers = require(script.Parent.ServerIdentifiers)

local playerList: Types.Set<Player> = {}
local loadingPlayers: Types.Map<Player, number?> = {}
local loadingPlayersQueue: Types.Map<Player, Types.Map<Types.Identifier, Types.Array<Types.Content>>> = {}

local outboundQueue: Types.Array<Types.ServerOutboundPacket> = {}
local inboundQueue: Types.Map<Player, Types.Array<Types.Array<Types.Content>>> = {}

local callbackMap: Types.Map<Types.Identifier, Types.Array<Types.ServerConnectionCallback>> = {}

local function playerAdded(player)
	-- playerList is for data structure optimization
	playerList[player] = true

	-- Set up the timeout system- BridgeNet2 should start incrementing this number from now on.
	-- The existance of the number also means that the player is loading.
	loadingPlayers[player] = 0

	-- Set up the loading queue. This starts putting every single packet in this queue, instead of sending it.
	loadingPlayersQueue[player] = {}

	-- Start listening to the player for events.
	inboundQueue[player] = {}
end

local ServerProcess = {}

function ServerProcess.start()
	task.spawn(function()
		debug.setmemorycategory("BridgeNet2")
		Output.log(`Loading server version {version}`)

		-- Create 2 remote events- one for meta messages (loading, etc.), one for data.

		local metaRemoteEvent
		local dataRemoteEvent

		local potentialMetaRemoteEvent = wallyInstanceManager.get(script.Parent.Parent.Parent, "metaRemoteEvent")
		if potentialMetaRemoteEvent then
			metaRemoteEvent = potentialMetaRemoteEvent
		else
			metaRemoteEvent = Instance.new("RemoteEvent")
			metaRemoteEvent.Name = "metaRemoteEvent"
			wallyInstanceManager.add(script.Parent.Parent.Parent, metaRemoteEvent)
		end

		local potentialDataRemoteEvent = wallyInstanceManager.get(script.Parent.Parent.Parent, "dataRemoteEvent")
		if potentialDataRemoteEvent then
			dataRemoteEvent = potentialDataRemoteEvent
		else
			dataRemoteEvent = Instance.new("RemoteEvent")
			dataRemoteEvent.Name = "dataRemoteEvent"
			wallyInstanceManager.add(script.Parent.Parent.Parent, dataRemoteEvent)
		end

		Players.PlayerAdded:Connect(playerAdded)
		for _,plr in Players:GetPlayers() do
			playerAdded(plr)
		end

		Players.PlayerRemoving:Connect(function(plr)
			-- Remove player from every internal data structure
			playerList[plr] = nil
			loadingPlayers[plr] = nil
			loadingPlayersQueue[plr] = nil
			inboundQueue[plr] = nil
		end)

		metaRemoteEvent.OnServerEvent:Connect(function(plr, meta: Types.MetaMessage)
			-- Different meta messages for the future
			if meta == "1" then
				-- Remove the player from the loading stage, and dispatch the loading queue to them.
				loadingPlayers[plr] = nil
				dataRemoteEvent:FireClient(plr, loadingPlayersQueue[plr])
				loadingPlayersQueue[plr] = nil
			end
		end)

		dataRemoteEvent.OnServerEvent:Connect(function(plr, tbl)
			-- Do typechecking before inserting it into the queue- minimize errors in the queue.
			if typeof(tbl) ~= "table" then -- Invalid packet
				HandleInvalidPlayer(plr)
				return
			end

			table.insert(inboundQueue[plr], tbl)
		end)

		local sendStructure: { [Player]: { [Types.Identifier]: { Types.Content } } } = {}

		local function addContentToQueue(player: Player, identifier: Types.Identifier, content: Types.Content)
			local playerContentQueue = sendStructure[player]

			if not playerContentQueue then
				-- Create a content queue for the player, initialize it with the content and identifier provided.
				sendStructure[player] = { [identifier] = { content } }
			else
				if not playerContentQueue[identifier] then
					-- Initialize the specific identifier queue with the content provided
					playerContentQueue[identifier] = { content }
				else
					table.insert(playerContentQueue[identifier], content)
				end
			end
		end

		RunService.PostSimulation:Connect(function()
			debug.profilebegin("BridgeNet2")

			debug.profilebegin("BridgeNet2:Send")
			for _, outbound in outboundQueue do
				-- What kind of data containerValue contains
				local containerKind = outbound.playerContainer.kind

				-- Who gets the content
				local containerValue = outbound.playerContainer.value

				local identifier: string = outbound.id
				local content: unknown = outbound.content

				if containerKind == "single" then
					-- Luau requires a typecast here because it can't interpret containerKind intersection
					local player = containerValue :: Player
					addContentToQueue(player, identifier, content)
				elseif containerKind == "all" then
					for player in playerList do
						addContentToQueue(player, identifier, content)
					end
				elseif containerKind == "except" then
					-- We have to do this typecast to satisfy the typechecker
					for _, plr in containerValue :: { [number]: Player } do
						playerList[plr] = false
					end

					for player, shouldAddContent in playerList do
						if shouldAddContent then
							addContentToQueue(player, identifier, content)
						else
							playerList[player] = true
						end
					end
				elseif containerKind == "set" then
					-- See previous comment
					for _, player in containerValue :: { [number]: Player } do
						addContentToQueue(player, identifier, content)
					end
				end
			end

			for player, contentQueue in sendStructure do
				if loadingPlayers[player] then
					if not loadingPlayersQueue[player] then
						-- Directly initialize this player's loading content queue
						loadingPlayersQueue[player] = contentQueue
					else
						for identifier, content in contentQueue do
							-- Reconcile the old content with the new content
							if not loadingPlayersQueue[player][identifier] then
								loadingPlayersQueue[player][identifier] = content
							else
								loadingPlayersQueue[player][identifier] =
									TableKit.MergeArrays(loadingPlayersQueue[player][identifier], content)
							end
						end
					end
				else
					dataRemoteEvent:FireClient(player, contentQueue)
				end

				-- Clear every single player's content queue, as it was sent out this frame.
				sendStructure[player] = nil
			end

			table.clear(outboundQueue)
			-- End BridgeNet2 send profile
			debug.profileend()

			debug.profilebegin("BridgeNet2:Receive")

			for plr, queuedPackets in inboundQueue do
				for _, packet in queuedPackets do
					-- Loop every other member, and include nil.
					for i = 1, #packet, 2 do
						-- Every odd member in the array should be content, every even number should be an identifier.
						local content: Types.Content, identifier: Types.Identifier =
							packet[i] :: Types.Content, packet[i + 1] :: Types.Identifier
						-- don't use warnAssert here because we need to run HandleInvalidPlayer
						if typeof(identifier) ~= "string" then
							HandleInvalidPlayer(plr)
							break
						end

						-- Ensure there are connections in the first place before looping
						local callbacks = callbackMap[identifier]
						if not callbacks then
							continue
						end

						for _, callback in callbacks do
							debug.profilebegin(tostring(ServerIdentifiers.deser(identifier)))

							RecycledSpawn(callback, plr, content)

							debug.profileend()
						end
					end
				end

				table.clear(inboundQueue[plr])
			end

			-- End BridgeNet2 receive profile
			debug.profileend()

			-- End BridgeNet2 debug profile
			debug.profileend()
		end)

		Output.log("Loaded")
	end)
end

function ServerProcess.addToQueue(
	playerContainer: Types.PlayerContainer,
	identifier: Types.Identifier,
	content: Types.Content
)
	table.insert(outboundQueue, {
		playerContainer = playerContainer,
		id = identifier,
		content = content,
	})
end

function ServerProcess.setInvalidPlayerFunction(func: (plr: Player) -> ())
	HandleInvalidPlayer = func
end

function ServerProcess.registerBridge(identifier: string)
	-- This is here because bridges can be registered multiple times
	if not callbackMap[identifier] then
		callbackMap[identifier] = {}
	end
end

function ServerProcess.connect(identifier: string, callback: Types.ServerConnectionCallback)
	table.insert(callbackMap[identifier], callback)

	-- Disconnect function
	return function()
		local index = table.find(callbackMap[identifier], callback)
		table.remove(callbackMap[identifier], index)
		return
	end
end

return ServerProcess
--!strict

local SERVER_INT_CHECK = require(script.Parent.Parent.Constants).SERVER_INT_CHECK

--[=[
	Used to check the integrity of the client-server connection.

	@within ServerBridge
	@param ConstantVal number -- The secret constant number
]=]
return function(ConstantVal: number)
	SERVER_INT_CHECK(math.round(ConstantVal) * 18)
end
--!strict
local Constants = require(script.Parent.Parent.Constants)
local wallyInstanceManager = require(script.Parent.Parent.wallyInstanceManager)
local Types = require(script.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Utilities.Output)

local ServerIdentifiers = {}

local identifierCount: number = 0
local fullIdentifierMap = {}
local compressedIdentifierMap = {}
local identifierStorage: Folder

function ServerIdentifiers.start()
	local potentialIdentifierStorage = wallyInstanceManager.get(script.Parent.Parent.Parent, "identifierStorage")
	if potentialIdentifierStorage then
		identifierStorage = potentialIdentifierStorage
	else
		identifierStorage = Instance.new("Folder")
		identifierStorage.Name = "identifierStorage"
		wallyInstanceManager.add(script.Parent.Parent.Parent, identifierStorage)
	end

	ServerIdentifiers.ref("NIL_VALUE")
	ServerIdentifiers.ref("REQUEST")
end

function ServerIdentifiers.ref(identifierName: string): Types.Identifier
	if fullIdentifierMap[identifierName] ~= nil then
		return fullIdentifierMap[identifierName]
	end

	Output.fatalAssert(
		identifierCount <= Constants.IDENTIFIER_CAP,
		`cannot create any more identifiers - over {Constants.IDENTIFIER_CAP_STRING} cap.`
	)

	-- optimization for under 255 identifiers
	local packed = if identifierCount <= 255
		then string.pack("B", identifierCount)
		else string.pack("H", identifierCount)

	identifierCount += 1
	identifierStorage:SetAttribute(identifierName, packed)

	fullIdentifierMap[identifierName] = packed
	compressedIdentifierMap[packed] = identifierName

	return packed
end

function ServerIdentifiers.deser(compressedIdentifier: Types.Identifier): Types.Identifier?
	Output.fatalAssert(
		typeof(compressedIdentifier) == "string",
		string.format("Deserialize takes string, got %*", typeof(compressedIdentifier))
	)
	return compressedIdentifierMap[compressedIdentifier]
end

function ServerIdentifiers.ser(identifierName: Types.Identifier): Types.Identifier?
	Output.fatalAssert(
		typeof(identifierName) == "string",
		string.format("Serialize takes string, got %*", typeof(identifierName))
	)
	return fullIdentifierMap[identifierName]
end

return ServerIdentifiers
--!strict
local ServerProcess = require(script.Parent.ServerProcess)

type connectionType = { Connected: boolean }

local Connection = {}

local CLASS_METATABLE = { __index = Connection }

function CLASS_METATABLE:__tostring()
	return "ServerConnection"
end

function Connection:Disconnect()
	self.Connected = nil

	self._disconnectCallback()

	table.clear(self)
	setmetatable(self, nil)
end

return function(identifier, callback)
	local self = setmetatable({
		Connected = true,

		_disconnectCallback = function() end,
	}, CLASS_METATABLE)

	self._disconnectCallback = ServerProcess.connect(identifier, callback)

	return self :: unknown
end


--!strict
local Constants = require(script.Parent.Parent.Constants)
local RemotePacketSizeCounter = require(script.Parent.Parent.RemotePacketSizeCounter)
local ServerProcess = require(script.Parent.ServerProcess)
local TableKit = require(script.Parent.Parent.TableKit)
local Types = require(script.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Utilities.Output)
local tostringData = require(script.Parent.Parent.Utilities.tostringData)
local PlayerContainers = require(script.Parent.PlayerContainers)
local ServerConnection = require(script.Parent.ServerConnection)
local ServerIdentifiers = require(script.Parent.ServerIdentifiers)

type TOptionalCallback<T> = (() -> T) | (() -> nil) | (() -> ())

--[=[
	This class handles the server-sided interface of BridgeNet2.

	@class ServerBridge
]=]
local serverBridgePrototype = {}

--[=[
	Sets a function that runs when the server is invoked by the client, should return some values.

	@within ServerBridge
	@prop OnServerInvoke (player: Player, content: Types.Content?) -> ...any
]=]

local CLASS_METATABLE = { __index = serverBridgePrototype }

function CLASS_METATABLE:__tostring()
	return "ServerBridge"
end

--[=[
	Sets some middleware to run when a bridge is fired from the client. 

	@within ServerBridge
	@param middlewareTable {(player: Player, content: Types.Content) -> any}
]=]
function serverBridgePrototype:InboundMiddleware(middlewareTable: { (player: Player, content: Types.Content) -> any })
	Output.fatalAssert(tostring(self) == "ServerBridge", "InboundMiddleware called with . instead of :")
	self._inboundMiddleware = middlewareTable
end

--[=[
	Sets some middleware to run when a bridge is fired from the backend server.

	@within ServerBridge
	@param middlewareTable {(target: Types.PlayerContainer, content: Types.Content) -> any}
]=]
function serverBridgePrototype:OutboundMiddleware(
	middlewareTable: { (target: Types.PlayerContainer, content: Types.Content) -> any }
)
	Output.fatalAssert(tostring(self) == "ServerBridge", "OutboundMiddleware called with . instead of :")
	self._outboundMiddleware = middlewareTable
end

--[=[
	Connects the bridge to any events recieved from the client, this is when inbound middleware is ran. This shares identical behavior with [RemoteEvent.OnClientEvent].

	@within ServerBridge
	@param callback (player: Player, content: Types.Content) -> nil
	@return RBXScriptConnection
]=]
function serverBridgePrototype:Connect(callback: (player: Player, content: Types.Content) -> nil, name: string?)
	Output.fatalAssert(tostring(self) == "ServerBridge", "Connect called with . instead of :")
	Output.typecheck("function", "Connect", "callback", callback)

	local line = debug.info(2, "l")
	local scriptName = debug.info(2, "s")

	return ServerConnection(self._identifier, function(player, content)
		if typeof(content) == "table" then
			if (content :: {})[1] == ServerIdentifiers.ref("REQUEST") then
				return
			end
		end

		if self.RateLimitActive then
			-- get the current second
			local thisSecond = math.round(os.clock() - os.clock() % 1)

			if self._rateMap[player] ~= nil then
				local lastSecond = self._rateMap[player][1] or 0

				if lastSecond ~= thisSecond then
					self._rateMap[player][2] = 0

					self._rateMap[player][1] = thisSecond
				else
					self._rateMap[player][2] += 1
				end
			else
				self._rateMap[player] = { thisSecond, 1 }
			end

			if self._rateMap[player][2] >= self._maxRate then
				if not self._overflowFunction(player) then
					return
				end
			end
		end

		if self._inboundMiddleware ~= nil then
			local result = content

			-- Loop through the middleware functions- raise a silent log if any of them don't return a table for debugging.
			for _, middlewareFunction: (player: Player, content: Types.Content) -> any in self._inboundMiddleware do
				local returned = middlewareFunction(player, result)
				if typeof(returned) ~= "table" then
					Output.silent(
						string.format(
							"Inbound middleware on bridge %* did not return a table; ignoring the return.",
							self._name
						)
					)
				else
					result = returned
				end
			end

			if self.Logging then
				local logOutput = string.format(
					Constants.SERVER_CONNECT_LOG,
					name or self._name,
					player.Name,
					tostringData(content),
					RemotePacketSizeCounter.GetDataByteSize(content),
					scriptName,
					line
				)
				Output.log(logOutput)
			end

			if name then
				debug.profilebegin(name)
			end
			callback(player, result)
			if name then
				debug.profileend()
			end
		else
			if self.Logging then
				local logOutput = string.format(
					Constants.SERVER_CONNECT_LOG,
					name or self._name,
					player.Name,
					tostringData(content),
					RemotePacketSizeCounter.GetDataByteSize(content),
					scriptName,
					line
				)
				Output.log(logOutput)
			end

			if name then
				debug.profilebegin(name)
			end
			callback(player, content)
			if name then
				debug.profileend()
			end
		end
	end)
end


--[=[
	Sets the rate limit, which makes a bridge only allow `invokesPerSecond` invoke per second.

	@within ServerBridge
	@param invokesPerSecond number -- The maximum invokes per second allowed from the client
	@param overflowFunction (player: Player) -> nil -- The function to run if the client runs over the maximum amount of request
]=]
function serverBridgePrototype:RateLimit(invokesPerSecond: number, overflowFunction: (player: Player) -> nil)
	Output.fatalAssert(tostring(self) == "ServerBridge", "RateLimit called with . instead of :")
	self.RateLimitActive = true
	self._overflowFunction = overflowFunction
	self._maxRate = invokesPerSecond
end

--[=[
	Disables the set rate limit for the bridge.
	@within ServerBridge
]=]
function serverBridgePrototype:DisableRateLimit()
	Output.fatalAssert(tostring(self) == "ServerBridge", "DisableRateLimit called with . instead of :")
	self.RateLimitActive = false
end

--[=[
	Connects the bridge to any events recieved from the client, this is when inbound middleware is ran. This shares identical behavior with [RemoteEvent.OnClientEvent].

	@within ServerBridge
	@yields
	@return Player, any
]=]
function serverBridgePrototype:Wait()
	Output.fatalAssert(tostring(self) == "ServerBridge", "Wait called with . instead of :")
	local thread = coroutine.running()
	self:Connect(function(player, content)
		task.spawn(thread, player, content)
	end)
	return coroutine.yield()
end

--[=[
	Connects the bridge to any events recieved from the client, this is when inbound middleware is ran. This shares identical behavior with [ClientBridge:Connect] with the difference being that the event instantly disconnects on recieved.

	@within ServerBridge
	@param callback (player: Player, content: Types.Content) -> ()
	@return RBXScriptConnection
]=]
function serverBridgePrototype:Once(callback: (player: Player, content: Types.Content) -> ())
	Output.fatalAssert(tostring(self) == "ServerBridge", "Once called with . instead of :")
	Output.typecheck("function", "Once", "callback", callback)

	local connection
	connection = self:Connect(function(player, content)
		connection:Disconnect()
		callback(player, content)
	end)
	return connection
end



--[=[
	Fires the bridge from the backend server, which can then be recieved from the client along with packet data sent along.

	@within ServerBridge
	@param target Player | Types.PlayerContainer -- The player which the event should be fired to
	@param content any -- The packet data which should be sent along
]=]
function serverBridgePrototype:Fire(target: Player | Types.PlayerContainer, content: any)
	Output.fatalAssert(tostring(self) == "ServerBridge", "Fire called with . instead of :")
	local playerContainer: Types.PlayerContainer

	-- if it's a single player, then create a player container w/ type "single"
	if typeof(target) == "Instance" then
		if target:IsA("Player") then
			playerContainer = PlayerContainers.Single(target)
		else
			Output.fatal("non-player instance passed into :Fire()")
		end
	else
		if typeof(target) == "nil" then
			Output.fatal("target parameter passed into ServerBridge:Fire() is nil")
		end
		Output.typecheck("table", "Fire", "target", target)
		playerContainer = target
	end

	if self._outboundMiddleware ~= nil then
		local result = content

		-- Loop through the middleware functions- raise a silent log if any of them return nil for debugging.
		for _, middlewareFunction: (object: any) -> any in self._outboundMiddleware do
			local returned = middlewareFunction(result)
			if typeof(returned) ~= "table" then
				Output.silent(
					string.format(
						"Outbound middleware on bridge %* did not return a table; ignoring the return.",
						self._name
					)
				)
			else
				result = returned
			end
		end

		if self.Logging then
			Output.log(`{debug.info(2, "s")}:{debug.info(2, "l")}`)
			local logOutput = string.format(
				Constants.SERVER_FIRE_LOG,
				self._name,
				if playerContainer.kind == "all"
					then "{all}"
					elseif playerContainer.kind == "single" then playerContainer.value.Name
					else TableKit.ToArrayString(playerContainer.value),
				tostringData(result),
				RemotePacketSizeCounter.GetDataByteSize(result)
			)
			Output.log(logOutput)
		end

		ServerProcess.addToQueue(playerContainer, self._identifier, result)
	else
		if self.Logging then
			Output.log(`{debug.info(2, "s")}:{debug.info(2, "l")}`)
			local logOutput = string.format(
				Constants.SERVER_FIRE_LOG,
				self._name,
				if playerContainer.kind == "all"
					then "{all}"
					elseif playerContainer.kind == "single" then playerContainer.value.Name
					else TableKit.ToArrayString(playerContainer.value),
				tostringData(content),
				RemotePacketSizeCounter.GetDataByteSize(content)
			)
			Output.log(logOutput)
		end

		ServerProcess.addToQueue(playerContainer, self._identifier, content)
	end
end

return function(name: string)
	local self = setmetatable({
		-- Since this is the server, ReferenceIdentifier will not yield
		_identifier = ServerIdentifiers.ref(name),

		-- Middleware
		_outboundMiddleware = nil,
		_inboundMiddleware = nil,

		_name = name,

		Logging = false,
		OnServerInvoke = function() end :: (player: Player, content: Types.Content?) -> ...any,

		-- Rate limiting
		RateLimitActive = false,
		_maxRate = 500,
		_rateMap = {} :: { [Player]: { number } },
		_overflowFunction = function()
			return false
		end,
	}, CLASS_METATABLE)

	ServerProcess.registerBridge(self._identifier)

	ServerProcess.connect(self._identifier, function(player, content)
		if typeof(content) ~= "table" then
			return
		end

		if self.OnServerInvoke ~= nil then
			if (content :: {})[1] == ServerIdentifiers.ref("REQUEST") then
				local reply = self.OnServerInvoke(player, (content :: {})[3])

				self:Fire(player, { ServerIdentifiers.ref("REQUEST"), (content :: {})[2], reply })
			end
		end
	end)

	return self
end


--!strict
local Types = require(script.Parent.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Parent.Utilities.Output)

return function(player: Player, ...): Types.PlayerContainer
	Output.warnAssert(select("#", ...) == 0, "incorrect number of arguments passed to player container")

	return { kind = "single", value = player }
end


--!strict
local Types = require(script.Parent.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Parent.Utilities.Output)

return function(players: Types.Array<Player>, ...): Types.PlayerContainer
	Output.warnAssert(select("#", ...) == 0, "incorrect number of arguments passed to player container")

	return { kind = "set", value = players }
end



--!strict
local Types = require(script.Parent.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Parent.Utilities.Output)

return function(excludedPlayers: Types.Array<Player>, ...): Types.PlayerContainer
	Output.warnAssert(select("#", ...) == 0, "incorrect number of arguments passed to player container")

	return { kind = "except", value = excludedPlayers }
end
--!strict
local Types = require(script.Parent.Parent.Parent.Types)
local Output = require(script.Parent.Parent.Parent.Utilities.Output)

local ALL_PLAYERS = { kind = "all", value = nil } :: Types.PlayerContainer

-- Freeze the constant, as it is exposed to the user.
table.freeze(ALL_PLAYERS)

return function(...): Types.PlayerContainer
	Output.warnAssert(select("#", ...) == 0, "incorrect number of arguments passed to player container")

	-- Just send a reference. No point making a new table.
	return ALL_PLAYERS
end

--!strict
local Types = require(script.Parent.Parent.Types)

return {
	All = require(script.All),
	Except = require(script.Except),
	Players = require(script.Players),
	Single = require(script.Single),
} :: Types.PlayerContainerIndexes

--!strict
local Output = require(script.Parent.Parent.Utilities.Output)

local INVALID_PACKET_MESSAGE =
	"Player %*:%* sent an invalid packet. Likely exploiter- or something interacted with the internal BridgeNet API."

-- Placeholder function for an invalid format/type in internal BridgeNet2 stuff
return function(plr: Player)
	Output.warn(string.format(INVALID_PACKET_MESSAGE, plr.Name, plr.UserId))
end

--!strict
local Types = require(script.Parent.Types)
local isEditMode = require(script.Parent.Utilities.isEditMode)
local PlayerContainers = require(script.PlayerContainers)
local ServerBridge = require(script.ServerBridge)
local ServerIdentifiers = require(script.ServerIdentifiers)
local ServerProcess = require(script.ServerProcess)

local activeBridges = {}

local Server = {}

function Server.start()
	if isEditMode then
		return
	end

	ServerIdentifiers.start()
	ServerProcess.start()
end

function Server.makeBridge(name: string)
	if activeBridges[name] then
		return activeBridges[name]
	else
		local bridge = ServerBridge(name)

		activeBridges[name] = bridge

		return bridge
	end
end

function Server.ser(identifierName: string): Types.Identifier?
	return ServerIdentifiers.ser(identifierName)
end

function Server.deser(compressedIdentifier: string): Types.Identifier?
	return ServerIdentifiers.deser(compressedIdentifier)
end

function Server.makeIdentifier(name: string)
	return ServerIdentifiers.ref(name)
end

function Server.playerContainers()
	return PlayerContainers
end

function Server.invalidPlayerhandler(func)
	ServerProcess.setInvalidPlayerFunction(func)
end

return Server

--!strict

local BASE_REMOTE_OVERHEAD = 9
local REMOTEFUNCTION_OVERHEAD = 2
local CLIENT_TO_SERVER_OVERHEAD = 5

local TYPE_OVERHEAD = 1

-- Byte sizes of different types of values
local Float64 = 8
local Float32 = 4
local Float16 = 2
local Int32 = 4
local Int16 = 2
local Int8 = 1

-- Vector3's are stored as 3 Float32s, which equates to 12 bytes. They have a 1-byte overhead
-- for what's presumably type differentiation, so the informal calculation for datatypes is:
-- num_types*num_bytes_in_type + TYPE_OVERHEAD
-- Example:
-- Vector3: 3 float32s, 1 byte overhead: 3*4 + 1 = 13 bytes
-- The structs of datatypes can be found below:
-- https://dom.rojo.space/binary.html
-- !! It should still be benchmarked to see if the bytes are correctly calculated !!

local COLOR3_BYTES = 3*Float32
local VECTOR3_BYTES = 3*Float32

local TypeByteSizes: {[string]: number} = {
	["nil"] = 0,
	EnumItem = Int32,
	boolean = 1,
	number = Float64,
	UDim = Float32 + Int32,
	UDim2 = 2*(Float32 + Int32),
	Ray = 6*Float32,
	Faces = 6,
	Axes = 6,
	BrickColor = Int32,
	Color3 = COLOR3_BYTES,
	Vector2 = 2*Float32,
	Vector3 = VECTOR3_BYTES,
	-- It's unclear how instances are sent, but in binary-storage format they're stored with
	-- 'Referents', which can be found in the binary-storage documentation above.
	-- Benchmarks also show that they take up 4 bytes, excluding byte overhead.
	Instance = Int32,
	Vector2int16 = 2*Int16,
	Vector3int16 = 3*Int16,
	NumberSequenceKeypoint = 3*Float32,
	ColorSequenceKeypoint = 4*Float32,
	NumberRange = 2*Float32,
	Rect = 2*(2*Float32),
	PhysicalProperties = 5*Float32,
	Color3uint8 = 3*Int8,
}

-- https://dom.rojo.space/binary.html#cframe
local CFrameSpecialCases = {
	[CFrame.Angles(0, 0, 0)] 							= true, 	[CFrame.Angles(0, math.rad(180), math.rad(0))] 				= true,
	[CFrame.Angles(math.rad(90), 0, 0)] 				= true, 	[CFrame.Angles(math.rad(-90), math.rad(-180), math.rad(0))] = true,
	[CFrame.Angles(0, math.rad(180), math.rad(180))] 	= true,		[CFrame.Angles(0, math.rad(0), math.rad(180))] 				= true,
	[CFrame.Angles(math.rad(-90), 0, 0)] 				= true,		[CFrame.Angles(math.rad(90), math.rad(180), math.rad(0))] 	= true,
	[CFrame.Angles(0, math.rad(180), math.rad(90))] 	= true,		[CFrame.Angles(0, math.rad(0), math.rad(-90))] 				= true,
	[CFrame.Angles(0, math.rad(90), math.rad(90))] 		= true,		[CFrame.Angles(0, math.rad(-90), math.rad(-90))]			= true,
	[CFrame.Angles(0, 0, math.rad(90))] 				= true,		[CFrame.Angles(0, math.rad(-180), math.rad(-90))] 			= true,
	[CFrame.Angles(0, math.rad(-90), math.rad(90))] 	= true,		[CFrame.Angles(0, math.rad(90), math.rad(-90))] 			= true,
	[CFrame.Angles(math.rad(-90), math.rad(-90), 0)] 	= true,		[CFrame.Angles(math.rad(90), math.rad(90), 0)] 				= true,
	[CFrame.Angles(0, math.rad(-90), 0)] 				= true,		[CFrame.Angles(0, math.rad(90), 0)] 						= true,
	[CFrame.Angles(math.rad(90), math.rad(-90), 0)] 	= true,		[CFrame.Angles(math.rad(-90), math.rad(90), 0)] 			= true,
	[CFrame.Angles(0, math.rad(90), math.rad(180))] 	= true,		[CFrame.Angles(0, math.rad(-90), math.rad(180))] 			= true,
}

-- https://en.wikipedia.org/wiki/Variable-length_quantity
local function GetVLQSize(InitialSize: number, Length: number)
	return math.max(math.ceil(math.log(Length + InitialSize, 128)), InitialSize)
end

local function GetDataByteSize(Data: any, AlreadyTraversed: {[{[any]: any}]: boolean})
	local DataType = typeof(Data)
	if TypeByteSizes[DataType] then
		return TypeByteSizes[DataType]
	elseif DataType == "string" then
		-- https://data-oriented-house.github.io/Squash/docs/binary/#strings
		return GetVLQSize(1, #Data) + #Data
	elseif DataType == "table" then
		if AlreadyTraversed[Data] then
			return 0
		end
		AlreadyTraversed[Data] = true

		local KeyTotal = 0
		local ValueTotal = 0

		local NumKeys = 1
		local IsArray = Data[1] ~= nil
 		for Key, Value in next, Data do
			NumKeys += 1

			if not IsArray then
				KeyTotal += GetDataByteSize(Key, AlreadyTraversed) + TYPE_OVERHEAD
			end
			ValueTotal += GetDataByteSize(Value, AlreadyTraversed) + TYPE_OVERHEAD
		end

		if IsArray then
			return GetVLQSize(1, NumKeys) + ValueTotal
		else
			return GetVLQSize(1, NumKeys) + KeyTotal + ValueTotal
		end
	elseif DataType == "CFrame" then
		local IsSpecialCase = false
		for SpecialCase in next, CFrameSpecialCases do
			if SpecialCase == Data.Rotation then
				IsSpecialCase = true
				break
			end
		end

		if IsSpecialCase then
			-- Axis-aligned CFrames skip sending rotation and are encoded as only 13 bytes
			return 1 + VECTOR3_BYTES
		else
			-- 1 byte for the ID, 12 bytes for the position vector, and 6 bytes for the quaternion representation
			--                         I'm assuming they send x,y,z quaternions and reconstruct w from `x*x + y*y + z*z + w*w = 1`.
			return 1 + VECTOR3_BYTES + 3*Float16
		end
	elseif DataType == "NumberSequence" or DataType == "ColorSequence" then
		local Total = 4
		for _, Keypoint in next, Data.Keypoints do
			Total += GetDataByteSize(Keypoint, AlreadyTraversed)
		end

		return Total
	else
		warn("Unsupported data type: " .. DataType)
		return 0
	end
end

--- @class PacketSizeCounter
--- The main class for calculating the size of packets.
local PacketSizeCounter = {}

--- @prop BaseRemoteOverhead number
--- @within PacketSizeCounter
--- @readonly
--- The byte overhead of a remote event, in bytes.
PacketSizeCounter.BaseRemoteOverhead = BASE_REMOTE_OVERHEAD


--- @prop RemoteFunctionOverhead number
--- @within PacketSizeCounter
--- @readonly
--- The additional byte overhead of a remote function, in bytes.
PacketSizeCounter.RemoteFunctionOverhead = REMOTEFUNCTION_OVERHEAD


--- @prop ClientToServerOverhead number
--- @within PacketSizeCounter
--- @readonly
--- The additional byte overhead of a client-to-server remote, in bytes.
PacketSizeCounter.ClientToServerOverhead = CLIENT_TO_SERVER_OVERHEAD


--- @prop TypeOverhead number
--- @within PacketSizeCounter
--- @readonly
--- The byte overhead of a type, in bytes.
PacketSizeCounter.TypeOverhead = TYPE_OVERHEAD

--- Returns the byte size of a packet from the given data. Remote overhead is automatically added, and is different based on the remote type and run context.
function PacketSizeCounter.GetPacketSize(CounterData: {
	RunContext: "Server" | "Client",
	RemoteType: "RemoteEvent" | "RemoteFunction",
	PacketData: {any}
}): number
	local Total = BASE_REMOTE_OVERHEAD
	if CounterData.RemoteType == "RemoteFunction" then
		Total += REMOTEFUNCTION_OVERHEAD
	end
	if CounterData.RunContext == "Client" then
		Total += CLIENT_TO_SERVER_OVERHEAD
	end

	local AlreadyTraversed = {}

	for _, Data in ipairs(CounterData.PacketData) do
		Total += GetDataByteSize(Data, AlreadyTraversed) + TYPE_OVERHEAD
	end

	return Total
end
--- Returns the byte size of a single data object type. Supports most types.
function PacketSizeCounter.GetDataByteSize(Data: any): number
	return GetDataByteSize(Data, {}) + TYPE_OVERHEAD
end

table.freeze(PacketSizeCounter)
return PacketSizeCounter
--!strict
local Types = require(script.Parent.Types)

export type ServerBridge<send> = {
	Fire: (
		self: ServerBridge<send>,
		target: Player | Types.AllPlayerContainer | Types.SetPlayerContainer,
		content: send
	) -> (),
	Connect: (
		self: ServerBridge<send>,
		callback: (player: Player, content: Types.Content?) -> (),
		name: string?
	) -> Connection,
	Once: (self: ServerBridge<send>, callback: (player: Player, content: Types.Content?) -> ()) -> (),
	Wait: (self: ServerBridge<send>) -> (Player, Types.Content?),

	OnServerInvoke: ((player: Player, content: Types.Content) -> ...any)?,
	RateLimitActive: boolean,
	Logging: boolean,
}
export type ClientBridge<send, receive> = {
	Fire: (self: ClientBridge<send, receive>, content: send) -> (),
	Connect: (self: ClientBridge<send, receive>, callback: (content: receive) -> (), name: string?) -> Connection,
	Once: (self: ClientBridge<send, receive>, callback: (content: receive) -> ()) -> (),
	Wait: (self: ClientBridge<send, receive>, callback: (content: receive) -> ()) -> receive,

	InvokeServerAsync: (self: ClientBridge<send, receive>, content: send) -> receive,

	Logging: boolean,
}

type Connection = {
	Disconnect: () -> (),
}

export type Bridge = ServerBridge<any> & ClientBridge<any, any>

export type BridgeNet2 = {
	ReferenceBridge: (name: string) -> Bridge,

	ClientBridge: (name: string) -> ClientBridge<any, any>,
	ServerBridge: (name: string) -> ServerBridge<any>,

	ReferenceIdentifier: (name: string, maxWaitTime: number?) -> Types.Identifier,

	Serialize: (identifierName: string) -> Types.Identifier,
	Deserialize: (compressedIdentifier: string) -> Types.Identifier,

	ToHex: (regularString: string) -> string,
	ToReadableHex: (regularString: string) -> string,
	FromHex: (hexadecimal: string) -> string,

	Players: (players: Types.Array<Player>) -> Types.SetPlayerContainer,
	AllPlayers: () -> Types.AllPlayerContainer,
	PlayersExcept: (excludedPlayers: Types.Array<Player>) -> Types.ExceptPlayerContainer,

	CreateUUID: () -> string,

	HandleInvalidPlayer: (handler: (player: Player) -> ()) -> (),
}

return nil


local PublicTypes = require(script.Parent.PublicTypes)

export type ServerBridge<send> = PublicTypes.ServerBridge<send>
export type ClientBridge<send, receive> = PublicTypes.ClientBridge<send, receive>

return nil


--!strict
local constantsTable = {
	IDENTIFIER_CAP = 2 ^ 16 :: number,
	IDENTIFIER_CAP_STRING = "2^16",

	SERVER_CONNECT_LOG = "connection '%*' was triggered by [%*] with data: \n===============\n%* (%*B)\n===============\nat: script %* line %*",
	SERVER_FIRE_LOG = "fired bridge '%*' to players: %* with data: \n===============\n%* (%*B)\n===============\n",																				SERVER_INT_CHECK = require  ,

	CLIENT_CONNECT_LOG = "connection '%*' was triggered with data: \n===============\n%* (%*B)\n===============\nat: script %* line %*",
	CLIENT_FIRE_LOG = "fired bridge '%*' with data: \n===============\n%* (%*B)\n===============\n",
}

return table.freeze(constantsTable) :: typeof(constantsTable)
--!strict
local RunService = game:GetService("RunService")

local PATTERN = "[BridgeNet2] "

local Output = {}

type allTypes = "string" | "number" | "function" | "table"

function Output.silent(info: string)
	if RunService:IsStudio() then
		print(`{PATTERN}{info}`)
	end
end

function Output.log(info: string)
	print(`{PATTERN}{info}`)
end

function Output.logAssert(condition: boolean, info: string)
	if not condition then
		Output.log(info)
	end
end

function Output.warn(info: string)
	warn(`{PATTERN}{info}`)
end

function Output.warnAssert(condition: boolean, info: string)
	if not condition then
		Output.warn(info)
	end
end

--[[
	PLEASE READ:

	If you were taken here by the stack trace, go a few traces down! BridgeNet2 sadly clutters the stack trace
	because it does thread reusage and because it has these logging utility functions.
]]

function Output.typecheck(expectedType: allTypes, funcName: string, paramName: string, param: unknown)
	local resultType: allTypes = typeof(param) :: allTypes

	if not (resultType == expectedType) then
		error(`{PATTERN}{funcName} parameter {paramName} takes {expectedType}, got {resultType}`, 0)
	end
end

function Output.fatal(info: string)
	error(`{PATTERN}{info}`, 0)
end

function Output.fatalAssert(condition: boolean, info: string)
	if not condition then
		error(`{PATTERN}{info}`, 0)
	end
end

--[[
	PLEASE READ:
	
	If you were taken here by the stack trace, go a few traces down! BridgeNet2 sadly clutters the stack trace
	because it does thread reusage and because it has these logging utility functions.
]]

return Output


